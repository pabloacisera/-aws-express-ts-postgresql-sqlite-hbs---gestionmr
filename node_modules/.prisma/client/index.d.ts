
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserConfig
 * 
 */
export type UserConfig = $Result.DefaultSelection<Prisma.$UserConfigPayload>
/**
 * Model ControlRegister
 * 
 */
export type ControlRegister = $Result.DefaultSelection<Prisma.$ControlRegisterPayload>
/**
 * Model CertificateDocument
 * 
 */
export type CertificateDocument = $Result.DefaultSelection<Prisma.$CertificateDocumentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CertificateType: {
  C_MATRICULACION: 'C_MATRICULACION',
  SEGURO: 'SEGURO',
  RTO: 'RTO',
  TACOGRAFO: 'TACOGRAFO'
};

export type CertificateType = (typeof CertificateType)[keyof typeof CertificateType]

}

export type CertificateType = $Enums.CertificateType

export const CertificateType: typeof $Enums.CertificateType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userConfig`: Exposes CRUD operations for the **UserConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConfigs
    * const userConfigs = await prisma.userConfig.findMany()
    * ```
    */
  get userConfig(): Prisma.UserConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.controlRegister`: Exposes CRUD operations for the **ControlRegister** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ControlRegisters
    * const controlRegisters = await prisma.controlRegister.findMany()
    * ```
    */
  get controlRegister(): Prisma.ControlRegisterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificateDocument`: Exposes CRUD operations for the **CertificateDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertificateDocuments
    * const certificateDocuments = await prisma.certificateDocument.findMany()
    * ```
    */
  get certificateDocument(): Prisma.CertificateDocumentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserConfig: 'UserConfig',
    ControlRegister: 'ControlRegister',
    CertificateDocument: 'CertificateDocument'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userConfig" | "controlRegister" | "certificateDocument"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserConfig: {
        payload: Prisma.$UserConfigPayload<ExtArgs>
        fields: Prisma.UserConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>
          }
          findFirst: {
            args: Prisma.UserConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>
          }
          findMany: {
            args: Prisma.UserConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>[]
          }
          create: {
            args: Prisma.UserConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>
          }
          createMany: {
            args: Prisma.UserConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>[]
          }
          delete: {
            args: Prisma.UserConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>
          }
          update: {
            args: Prisma.UserConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>
          }
          deleteMany: {
            args: Prisma.UserConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>[]
          }
          upsert: {
            args: Prisma.UserConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConfigPayload>
          }
          aggregate: {
            args: Prisma.UserConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConfig>
          }
          groupBy: {
            args: Prisma.UserConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConfigCountArgs<ExtArgs>
            result: $Utils.Optional<UserConfigCountAggregateOutputType> | number
          }
        }
      }
      ControlRegister: {
        payload: Prisma.$ControlRegisterPayload<ExtArgs>
        fields: Prisma.ControlRegisterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ControlRegisterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ControlRegisterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>
          }
          findFirst: {
            args: Prisma.ControlRegisterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ControlRegisterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>
          }
          findMany: {
            args: Prisma.ControlRegisterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>[]
          }
          create: {
            args: Prisma.ControlRegisterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>
          }
          createMany: {
            args: Prisma.ControlRegisterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ControlRegisterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>[]
          }
          delete: {
            args: Prisma.ControlRegisterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>
          }
          update: {
            args: Prisma.ControlRegisterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>
          }
          deleteMany: {
            args: Prisma.ControlRegisterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ControlRegisterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ControlRegisterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>[]
          }
          upsert: {
            args: Prisma.ControlRegisterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlRegisterPayload>
          }
          aggregate: {
            args: Prisma.ControlRegisterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateControlRegister>
          }
          groupBy: {
            args: Prisma.ControlRegisterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ControlRegisterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ControlRegisterCountArgs<ExtArgs>
            result: $Utils.Optional<ControlRegisterCountAggregateOutputType> | number
          }
        }
      }
      CertificateDocument: {
        payload: Prisma.$CertificateDocumentPayload<ExtArgs>
        fields: Prisma.CertificateDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>
          }
          findFirst: {
            args: Prisma.CertificateDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>
          }
          findMany: {
            args: Prisma.CertificateDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>[]
          }
          create: {
            args: Prisma.CertificateDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>
          }
          createMany: {
            args: Prisma.CertificateDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>[]
          }
          delete: {
            args: Prisma.CertificateDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>
          }
          update: {
            args: Prisma.CertificateDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CertificateDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>[]
          }
          upsert: {
            args: Prisma.CertificateDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateDocumentPayload>
          }
          aggregate: {
            args: Prisma.CertificateDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificateDocument>
          }
          groupBy: {
            args: Prisma.CertificateDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateDocumentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userConfig?: UserConfigOmit
    controlRegister?: ControlRegisterOmit
    certificateDocument?: CertificateDocumentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    controlRegister: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    controlRegister?: boolean | UserCountOutputTypeCountControlRegisterArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountControlRegisterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ControlRegisterWhereInput
  }


  /**
   * Count Type ControlRegisterCountOutputType
   */

  export type ControlRegisterCountOutputType = {
    certificates: number
  }

  export type ControlRegisterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | ControlRegisterCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * ControlRegisterCountOutputType without action
   */
  export type ControlRegisterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegisterCountOutputType
     */
    select?: ControlRegisterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ControlRegisterCountOutputType without action
   */
  export type ControlRegisterCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateDocumentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    password: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    config?: boolean | User$configArgs<ExtArgs>
    controlRegister?: boolean | User$controlRegisterArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | User$configArgs<ExtArgs>
    controlRegister?: boolean | User$controlRegisterArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      config: Prisma.$UserConfigPayload<ExtArgs> | null
      controlRegister: Prisma.$ControlRegisterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      password: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    config<T extends User$configArgs<ExtArgs> = {}>(args?: Subset<T, User$configArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    controlRegister<T extends User$controlRegisterArgs<ExtArgs> = {}>(args?: Subset<T, User$controlRegisterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.config
   */
  export type User$configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    where?: UserConfigWhereInput
  }

  /**
   * User.controlRegister
   */
  export type User$controlRegisterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    where?: ControlRegisterWhereInput
    orderBy?: ControlRegisterOrderByWithRelationInput | ControlRegisterOrderByWithRelationInput[]
    cursor?: ControlRegisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ControlRegisterScalarFieldEnum | ControlRegisterScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserConfig
   */

  export type AggregateUserConfig = {
    _count: UserConfigCountAggregateOutputType | null
    _avg: UserConfigAvgAggregateOutputType | null
    _sum: UserConfigSumAggregateOutputType | null
    _min: UserConfigMinAggregateOutputType | null
    _max: UserConfigMaxAggregateOutputType | null
  }

  export type UserConfigAvgAggregateOutputType = {
    userId: number | null
  }

  export type UserConfigSumAggregateOutputType = {
    userId: number | null
  }

  export type UserConfigMinAggregateOutputType = {
    id: string | null
    userId: number | null
    pdfGenerate: boolean | null
    showAllRegistries: boolean | null
    cacheRegistries: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserConfigMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    pdfGenerate: boolean | null
    showAllRegistries: boolean | null
    cacheRegistries: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserConfigCountAggregateOutputType = {
    id: number
    userId: number
    pdfGenerate: number
    showAllRegistries: number
    cacheRegistries: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserConfigAvgAggregateInputType = {
    userId?: true
  }

  export type UserConfigSumAggregateInputType = {
    userId?: true
  }

  export type UserConfigMinAggregateInputType = {
    id?: true
    userId?: true
    pdfGenerate?: true
    showAllRegistries?: true
    cacheRegistries?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserConfigMaxAggregateInputType = {
    id?: true
    userId?: true
    pdfGenerate?: true
    showAllRegistries?: true
    cacheRegistries?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserConfigCountAggregateInputType = {
    id?: true
    userId?: true
    pdfGenerate?: true
    showAllRegistries?: true
    cacheRegistries?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConfig to aggregate.
     */
    where?: UserConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConfigs to fetch.
     */
    orderBy?: UserConfigOrderByWithRelationInput | UserConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConfigs
    **/
    _count?: true | UserConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConfigMaxAggregateInputType
  }

  export type GetUserConfigAggregateType<T extends UserConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConfig[P]>
      : GetScalarType<T[P], AggregateUserConfig[P]>
  }




  export type UserConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConfigWhereInput
    orderBy?: UserConfigOrderByWithAggregationInput | UserConfigOrderByWithAggregationInput[]
    by: UserConfigScalarFieldEnum[] | UserConfigScalarFieldEnum
    having?: UserConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConfigCountAggregateInputType | true
    _avg?: UserConfigAvgAggregateInputType
    _sum?: UserConfigSumAggregateInputType
    _min?: UserConfigMinAggregateInputType
    _max?: UserConfigMaxAggregateInputType
  }

  export type UserConfigGroupByOutputType = {
    id: string
    userId: number
    pdfGenerate: boolean
    showAllRegistries: boolean
    cacheRegistries: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserConfigCountAggregateOutputType | null
    _avg: UserConfigAvgAggregateOutputType | null
    _sum: UserConfigSumAggregateOutputType | null
    _min: UserConfigMinAggregateOutputType | null
    _max: UserConfigMaxAggregateOutputType | null
  }

  type GetUserConfigGroupByPayload<T extends UserConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConfigGroupByOutputType[P]>
            : GetScalarType<T[P], UserConfigGroupByOutputType[P]>
        }
      >
    >


  export type UserConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConfig"]>

  export type UserConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConfig"]>

  export type UserConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConfig"]>

  export type UserConfigSelectScalar = {
    id?: boolean
    userId?: boolean
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "pdfGenerate" | "showAllRegistries" | "cacheRegistries" | "createdAt" | "updatedAt", ExtArgs["result"]["userConfig"]>
  export type UserConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConfig"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      pdfGenerate: boolean
      showAllRegistries: boolean
      cacheRegistries: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userConfig"]>
    composites: {}
  }

  type UserConfigGetPayload<S extends boolean | null | undefined | UserConfigDefaultArgs> = $Result.GetResult<Prisma.$UserConfigPayload, S>

  type UserConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserConfigCountAggregateInputType | true
    }

  export interface UserConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConfig'], meta: { name: 'UserConfig' } }
    /**
     * Find zero or one UserConfig that matches the filter.
     * @param {UserConfigFindUniqueArgs} args - Arguments to find a UserConfig
     * @example
     * // Get one UserConfig
     * const userConfig = await prisma.userConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConfigFindUniqueArgs>(args: SelectSubset<T, UserConfigFindUniqueArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserConfigFindUniqueOrThrowArgs} args - Arguments to find a UserConfig
     * @example
     * // Get one UserConfig
     * const userConfig = await prisma.userConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigFindFirstArgs} args - Arguments to find a UserConfig
     * @example
     * // Get one UserConfig
     * const userConfig = await prisma.userConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConfigFindFirstArgs>(args?: SelectSubset<T, UserConfigFindFirstArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigFindFirstOrThrowArgs} args - Arguments to find a UserConfig
     * @example
     * // Get one UserConfig
     * const userConfig = await prisma.userConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConfigs
     * const userConfigs = await prisma.userConfig.findMany()
     * 
     * // Get first 10 UserConfigs
     * const userConfigs = await prisma.userConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userConfigWithIdOnly = await prisma.userConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserConfigFindManyArgs>(args?: SelectSubset<T, UserConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserConfig.
     * @param {UserConfigCreateArgs} args - Arguments to create a UserConfig.
     * @example
     * // Create one UserConfig
     * const UserConfig = await prisma.userConfig.create({
     *   data: {
     *     // ... data to create a UserConfig
     *   }
     * })
     * 
     */
    create<T extends UserConfigCreateArgs>(args: SelectSubset<T, UserConfigCreateArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserConfigs.
     * @param {UserConfigCreateManyArgs} args - Arguments to create many UserConfigs.
     * @example
     * // Create many UserConfigs
     * const userConfig = await prisma.userConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConfigCreateManyArgs>(args?: SelectSubset<T, UserConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConfigs and returns the data saved in the database.
     * @param {UserConfigCreateManyAndReturnArgs} args - Arguments to create many UserConfigs.
     * @example
     * // Create many UserConfigs
     * const userConfig = await prisma.userConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConfigs and only return the `id`
     * const userConfigWithIdOnly = await prisma.userConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserConfig.
     * @param {UserConfigDeleteArgs} args - Arguments to delete one UserConfig.
     * @example
     * // Delete one UserConfig
     * const UserConfig = await prisma.userConfig.delete({
     *   where: {
     *     // ... filter to delete one UserConfig
     *   }
     * })
     * 
     */
    delete<T extends UserConfigDeleteArgs>(args: SelectSubset<T, UserConfigDeleteArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserConfig.
     * @param {UserConfigUpdateArgs} args - Arguments to update one UserConfig.
     * @example
     * // Update one UserConfig
     * const userConfig = await prisma.userConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConfigUpdateArgs>(args: SelectSubset<T, UserConfigUpdateArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserConfigs.
     * @param {UserConfigDeleteManyArgs} args - Arguments to filter UserConfigs to delete.
     * @example
     * // Delete a few UserConfigs
     * const { count } = await prisma.userConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConfigDeleteManyArgs>(args?: SelectSubset<T, UserConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConfigs
     * const userConfig = await prisma.userConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConfigUpdateManyArgs>(args: SelectSubset<T, UserConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConfigs and returns the data updated in the database.
     * @param {UserConfigUpdateManyAndReturnArgs} args - Arguments to update many UserConfigs.
     * @example
     * // Update many UserConfigs
     * const userConfig = await prisma.userConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserConfigs and only return the `id`
     * const userConfigWithIdOnly = await prisma.userConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, UserConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserConfig.
     * @param {UserConfigUpsertArgs} args - Arguments to update or create a UserConfig.
     * @example
     * // Update or create a UserConfig
     * const userConfig = await prisma.userConfig.upsert({
     *   create: {
     *     // ... data to create a UserConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConfig we want to update
     *   }
     * })
     */
    upsert<T extends UserConfigUpsertArgs>(args: SelectSubset<T, UserConfigUpsertArgs<ExtArgs>>): Prisma__UserConfigClient<$Result.GetResult<Prisma.$UserConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigCountArgs} args - Arguments to filter UserConfigs to count.
     * @example
     * // Count the number of UserConfigs
     * const count = await prisma.userConfig.count({
     *   where: {
     *     // ... the filter for the UserConfigs we want to count
     *   }
     * })
    **/
    count<T extends UserConfigCountArgs>(
      args?: Subset<T, UserConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConfigAggregateArgs>(args: Subset<T, UserConfigAggregateArgs>): Prisma.PrismaPromise<GetUserConfigAggregateType<T>>

    /**
     * Group by UserConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConfigGroupByArgs['orderBy'] }
        : { orderBy?: UserConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConfig model
   */
  readonly fields: UserConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConfig model
   */
  interface UserConfigFieldRefs {
    readonly id: FieldRef<"UserConfig", 'String'>
    readonly userId: FieldRef<"UserConfig", 'Int'>
    readonly pdfGenerate: FieldRef<"UserConfig", 'Boolean'>
    readonly showAllRegistries: FieldRef<"UserConfig", 'Boolean'>
    readonly cacheRegistries: FieldRef<"UserConfig", 'Boolean'>
    readonly createdAt: FieldRef<"UserConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"UserConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserConfig findUnique
   */
  export type UserConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * Filter, which UserConfig to fetch.
     */
    where: UserConfigWhereUniqueInput
  }

  /**
   * UserConfig findUniqueOrThrow
   */
  export type UserConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * Filter, which UserConfig to fetch.
     */
    where: UserConfigWhereUniqueInput
  }

  /**
   * UserConfig findFirst
   */
  export type UserConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * Filter, which UserConfig to fetch.
     */
    where?: UserConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConfigs to fetch.
     */
    orderBy?: UserConfigOrderByWithRelationInput | UserConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConfigs.
     */
    cursor?: UserConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConfigs.
     */
    distinct?: UserConfigScalarFieldEnum | UserConfigScalarFieldEnum[]
  }

  /**
   * UserConfig findFirstOrThrow
   */
  export type UserConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * Filter, which UserConfig to fetch.
     */
    where?: UserConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConfigs to fetch.
     */
    orderBy?: UserConfigOrderByWithRelationInput | UserConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConfigs.
     */
    cursor?: UserConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConfigs.
     */
    distinct?: UserConfigScalarFieldEnum | UserConfigScalarFieldEnum[]
  }

  /**
   * UserConfig findMany
   */
  export type UserConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * Filter, which UserConfigs to fetch.
     */
    where?: UserConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConfigs to fetch.
     */
    orderBy?: UserConfigOrderByWithRelationInput | UserConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConfigs.
     */
    cursor?: UserConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConfigs.
     */
    skip?: number
    distinct?: UserConfigScalarFieldEnum | UserConfigScalarFieldEnum[]
  }

  /**
   * UserConfig create
   */
  export type UserConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConfig.
     */
    data: XOR<UserConfigCreateInput, UserConfigUncheckedCreateInput>
  }

  /**
   * UserConfig createMany
   */
  export type UserConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConfigs.
     */
    data: UserConfigCreateManyInput | UserConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConfig createManyAndReturn
   */
  export type UserConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * The data used to create many UserConfigs.
     */
    data: UserConfigCreateManyInput | UserConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConfig update
   */
  export type UserConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConfig.
     */
    data: XOR<UserConfigUpdateInput, UserConfigUncheckedUpdateInput>
    /**
     * Choose, which UserConfig to update.
     */
    where: UserConfigWhereUniqueInput
  }

  /**
   * UserConfig updateMany
   */
  export type UserConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConfigs.
     */
    data: XOR<UserConfigUpdateManyMutationInput, UserConfigUncheckedUpdateManyInput>
    /**
     * Filter which UserConfigs to update
     */
    where?: UserConfigWhereInput
    /**
     * Limit how many UserConfigs to update.
     */
    limit?: number
  }

  /**
   * UserConfig updateManyAndReturn
   */
  export type UserConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * The data used to update UserConfigs.
     */
    data: XOR<UserConfigUpdateManyMutationInput, UserConfigUncheckedUpdateManyInput>
    /**
     * Filter which UserConfigs to update
     */
    where?: UserConfigWhereInput
    /**
     * Limit how many UserConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConfig upsert
   */
  export type UserConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConfig to update in case it exists.
     */
    where: UserConfigWhereUniqueInput
    /**
     * In case the UserConfig found by the `where` argument doesn't exist, create a new UserConfig with this data.
     */
    create: XOR<UserConfigCreateInput, UserConfigUncheckedCreateInput>
    /**
     * In case the UserConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConfigUpdateInput, UserConfigUncheckedUpdateInput>
  }

  /**
   * UserConfig delete
   */
  export type UserConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
    /**
     * Filter which UserConfig to delete.
     */
    where: UserConfigWhereUniqueInput
  }

  /**
   * UserConfig deleteMany
   */
  export type UserConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConfigs to delete
     */
    where?: UserConfigWhereInput
    /**
     * Limit how many UserConfigs to delete.
     */
    limit?: number
  }

  /**
   * UserConfig without action
   */
  export type UserConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConfig
     */
    select?: UserConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConfig
     */
    omit?: UserConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConfigInclude<ExtArgs> | null
  }


  /**
   * Model ControlRegister
   */

  export type AggregateControlRegister = {
    _count: ControlRegisterCountAggregateOutputType | null
    _avg: ControlRegisterAvgAggregateOutputType | null
    _sum: ControlRegisterSumAggregateOutputType | null
    _min: ControlRegisterMinAggregateOutputType | null
    _max: ControlRegisterMaxAggregateOutputType | null
  }

  export type ControlRegisterAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ControlRegisterSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ControlRegisterMinAggregateOutputType = {
    id: number | null
    userId: number | null
    agente: string | null
    fecha: Date | null
    lugar: string | null
    conductor_nombre: string | null
    licencia_tipo: string | null
    licencia_numero: string | null
    licencia_vencimiento: Date | null
    empresa_select: string | null
    dominio: string | null
    interno: string | null
    c_matriculacion_venc: Date | null
    c_matriculacion_cert: string | null
    seguro_venc: Date | null
    seguro_cert: string | null
    rto_venc: Date | null
    rto_cert: string | null
    tacografo_venc: Date | null
    tacografo_cert: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ControlRegisterMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    agente: string | null
    fecha: Date | null
    lugar: string | null
    conductor_nombre: string | null
    licencia_tipo: string | null
    licencia_numero: string | null
    licencia_vencimiento: Date | null
    empresa_select: string | null
    dominio: string | null
    interno: string | null
    c_matriculacion_venc: Date | null
    c_matriculacion_cert: string | null
    seguro_venc: Date | null
    seguro_cert: string | null
    rto_venc: Date | null
    rto_cert: string | null
    tacografo_venc: Date | null
    tacografo_cert: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ControlRegisterCountAggregateOutputType = {
    id: number
    userId: number
    agente: number
    fecha: number
    lugar: number
    conductor_nombre: number
    licencia_tipo: number
    licencia_numero: number
    licencia_vencimiento: number
    empresa_select: number
    dominio: number
    interno: number
    c_matriculacion_venc: number
    c_matriculacion_cert: number
    seguro_venc: number
    seguro_cert: number
    rto_venc: number
    rto_cert: number
    tacografo_venc: number
    tacografo_cert: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ControlRegisterAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ControlRegisterSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ControlRegisterMinAggregateInputType = {
    id?: true
    userId?: true
    agente?: true
    fecha?: true
    lugar?: true
    conductor_nombre?: true
    licencia_tipo?: true
    licencia_numero?: true
    licencia_vencimiento?: true
    empresa_select?: true
    dominio?: true
    interno?: true
    c_matriculacion_venc?: true
    c_matriculacion_cert?: true
    seguro_venc?: true
    seguro_cert?: true
    rto_venc?: true
    rto_cert?: true
    tacografo_venc?: true
    tacografo_cert?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ControlRegisterMaxAggregateInputType = {
    id?: true
    userId?: true
    agente?: true
    fecha?: true
    lugar?: true
    conductor_nombre?: true
    licencia_tipo?: true
    licencia_numero?: true
    licencia_vencimiento?: true
    empresa_select?: true
    dominio?: true
    interno?: true
    c_matriculacion_venc?: true
    c_matriculacion_cert?: true
    seguro_venc?: true
    seguro_cert?: true
    rto_venc?: true
    rto_cert?: true
    tacografo_venc?: true
    tacografo_cert?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ControlRegisterCountAggregateInputType = {
    id?: true
    userId?: true
    agente?: true
    fecha?: true
    lugar?: true
    conductor_nombre?: true
    licencia_tipo?: true
    licencia_numero?: true
    licencia_vencimiento?: true
    empresa_select?: true
    dominio?: true
    interno?: true
    c_matriculacion_venc?: true
    c_matriculacion_cert?: true
    seguro_venc?: true
    seguro_cert?: true
    rto_venc?: true
    rto_cert?: true
    tacografo_venc?: true
    tacografo_cert?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ControlRegisterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlRegister to aggregate.
     */
    where?: ControlRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlRegisters to fetch.
     */
    orderBy?: ControlRegisterOrderByWithRelationInput | ControlRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ControlRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ControlRegisters
    **/
    _count?: true | ControlRegisterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ControlRegisterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ControlRegisterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ControlRegisterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ControlRegisterMaxAggregateInputType
  }

  export type GetControlRegisterAggregateType<T extends ControlRegisterAggregateArgs> = {
        [P in keyof T & keyof AggregateControlRegister]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateControlRegister[P]>
      : GetScalarType<T[P], AggregateControlRegister[P]>
  }




  export type ControlRegisterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ControlRegisterWhereInput
    orderBy?: ControlRegisterOrderByWithAggregationInput | ControlRegisterOrderByWithAggregationInput[]
    by: ControlRegisterScalarFieldEnum[] | ControlRegisterScalarFieldEnum
    having?: ControlRegisterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ControlRegisterCountAggregateInputType | true
    _avg?: ControlRegisterAvgAggregateInputType
    _sum?: ControlRegisterSumAggregateInputType
    _min?: ControlRegisterMinAggregateInputType
    _max?: ControlRegisterMaxAggregateInputType
  }

  export type ControlRegisterGroupByOutputType = {
    id: number
    userId: number
    agente: string
    fecha: Date | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento: Date | null
    empresa_select: string
    dominio: string
    interno: string | null
    c_matriculacion_venc: Date | null
    c_matriculacion_cert: string | null
    seguro_venc: Date | null
    seguro_cert: string | null
    rto_venc: Date | null
    rto_cert: string | null
    tacografo_venc: Date | null
    tacografo_cert: string | null
    createdAt: Date
    updatedAt: Date
    _count: ControlRegisterCountAggregateOutputType | null
    _avg: ControlRegisterAvgAggregateOutputType | null
    _sum: ControlRegisterSumAggregateOutputType | null
    _min: ControlRegisterMinAggregateOutputType | null
    _max: ControlRegisterMaxAggregateOutputType | null
  }

  type GetControlRegisterGroupByPayload<T extends ControlRegisterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ControlRegisterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ControlRegisterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ControlRegisterGroupByOutputType[P]>
            : GetScalarType<T[P], ControlRegisterGroupByOutputType[P]>
        }
      >
    >


  export type ControlRegisterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agente?: boolean
    fecha?: boolean
    lugar?: boolean
    conductor_nombre?: boolean
    licencia_tipo?: boolean
    licencia_numero?: boolean
    licencia_vencimiento?: boolean
    empresa_select?: boolean
    dominio?: boolean
    interno?: boolean
    c_matriculacion_venc?: boolean
    c_matriculacion_cert?: boolean
    seguro_venc?: boolean
    seguro_cert?: boolean
    rto_venc?: boolean
    rto_cert?: boolean
    tacografo_venc?: boolean
    tacografo_cert?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    certificates?: boolean | ControlRegister$certificatesArgs<ExtArgs>
    _count?: boolean | ControlRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["controlRegister"]>

  export type ControlRegisterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agente?: boolean
    fecha?: boolean
    lugar?: boolean
    conductor_nombre?: boolean
    licencia_tipo?: boolean
    licencia_numero?: boolean
    licencia_vencimiento?: boolean
    empresa_select?: boolean
    dominio?: boolean
    interno?: boolean
    c_matriculacion_venc?: boolean
    c_matriculacion_cert?: boolean
    seguro_venc?: boolean
    seguro_cert?: boolean
    rto_venc?: boolean
    rto_cert?: boolean
    tacografo_venc?: boolean
    tacografo_cert?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["controlRegister"]>

  export type ControlRegisterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agente?: boolean
    fecha?: boolean
    lugar?: boolean
    conductor_nombre?: boolean
    licencia_tipo?: boolean
    licencia_numero?: boolean
    licencia_vencimiento?: boolean
    empresa_select?: boolean
    dominio?: boolean
    interno?: boolean
    c_matriculacion_venc?: boolean
    c_matriculacion_cert?: boolean
    seguro_venc?: boolean
    seguro_cert?: boolean
    rto_venc?: boolean
    rto_cert?: boolean
    tacografo_venc?: boolean
    tacografo_cert?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["controlRegister"]>

  export type ControlRegisterSelectScalar = {
    id?: boolean
    userId?: boolean
    agente?: boolean
    fecha?: boolean
    lugar?: boolean
    conductor_nombre?: boolean
    licencia_tipo?: boolean
    licencia_numero?: boolean
    licencia_vencimiento?: boolean
    empresa_select?: boolean
    dominio?: boolean
    interno?: boolean
    c_matriculacion_venc?: boolean
    c_matriculacion_cert?: boolean
    seguro_venc?: boolean
    seguro_cert?: boolean
    rto_venc?: boolean
    rto_cert?: boolean
    tacografo_venc?: boolean
    tacografo_cert?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ControlRegisterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agente" | "fecha" | "lugar" | "conductor_nombre" | "licencia_tipo" | "licencia_numero" | "licencia_vencimiento" | "empresa_select" | "dominio" | "interno" | "c_matriculacion_venc" | "c_matriculacion_cert" | "seguro_venc" | "seguro_cert" | "rto_venc" | "rto_cert" | "tacografo_venc" | "tacografo_cert" | "createdAt" | "updatedAt", ExtArgs["result"]["controlRegister"]>
  export type ControlRegisterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    certificates?: boolean | ControlRegister$certificatesArgs<ExtArgs>
    _count?: boolean | ControlRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ControlRegisterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ControlRegisterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ControlRegisterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ControlRegister"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      certificates: Prisma.$CertificateDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      agente: string
      fecha: Date | null
      lugar: string
      conductor_nombre: string
      licencia_tipo: string
      licencia_numero: string
      licencia_vencimiento: Date | null
      empresa_select: string
      dominio: string
      interno: string | null
      c_matriculacion_venc: Date | null
      c_matriculacion_cert: string | null
      seguro_venc: Date | null
      seguro_cert: string | null
      rto_venc: Date | null
      rto_cert: string | null
      tacografo_venc: Date | null
      tacografo_cert: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["controlRegister"]>
    composites: {}
  }

  type ControlRegisterGetPayload<S extends boolean | null | undefined | ControlRegisterDefaultArgs> = $Result.GetResult<Prisma.$ControlRegisterPayload, S>

  type ControlRegisterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ControlRegisterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ControlRegisterCountAggregateInputType | true
    }

  export interface ControlRegisterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ControlRegister'], meta: { name: 'ControlRegister' } }
    /**
     * Find zero or one ControlRegister that matches the filter.
     * @param {ControlRegisterFindUniqueArgs} args - Arguments to find a ControlRegister
     * @example
     * // Get one ControlRegister
     * const controlRegister = await prisma.controlRegister.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ControlRegisterFindUniqueArgs>(args: SelectSubset<T, ControlRegisterFindUniqueArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ControlRegister that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ControlRegisterFindUniqueOrThrowArgs} args - Arguments to find a ControlRegister
     * @example
     * // Get one ControlRegister
     * const controlRegister = await prisma.controlRegister.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ControlRegisterFindUniqueOrThrowArgs>(args: SelectSubset<T, ControlRegisterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ControlRegister that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterFindFirstArgs} args - Arguments to find a ControlRegister
     * @example
     * // Get one ControlRegister
     * const controlRegister = await prisma.controlRegister.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ControlRegisterFindFirstArgs>(args?: SelectSubset<T, ControlRegisterFindFirstArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ControlRegister that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterFindFirstOrThrowArgs} args - Arguments to find a ControlRegister
     * @example
     * // Get one ControlRegister
     * const controlRegister = await prisma.controlRegister.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ControlRegisterFindFirstOrThrowArgs>(args?: SelectSubset<T, ControlRegisterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ControlRegisters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ControlRegisters
     * const controlRegisters = await prisma.controlRegister.findMany()
     * 
     * // Get first 10 ControlRegisters
     * const controlRegisters = await prisma.controlRegister.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const controlRegisterWithIdOnly = await prisma.controlRegister.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ControlRegisterFindManyArgs>(args?: SelectSubset<T, ControlRegisterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ControlRegister.
     * @param {ControlRegisterCreateArgs} args - Arguments to create a ControlRegister.
     * @example
     * // Create one ControlRegister
     * const ControlRegister = await prisma.controlRegister.create({
     *   data: {
     *     // ... data to create a ControlRegister
     *   }
     * })
     * 
     */
    create<T extends ControlRegisterCreateArgs>(args: SelectSubset<T, ControlRegisterCreateArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ControlRegisters.
     * @param {ControlRegisterCreateManyArgs} args - Arguments to create many ControlRegisters.
     * @example
     * // Create many ControlRegisters
     * const controlRegister = await prisma.controlRegister.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ControlRegisterCreateManyArgs>(args?: SelectSubset<T, ControlRegisterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ControlRegisters and returns the data saved in the database.
     * @param {ControlRegisterCreateManyAndReturnArgs} args - Arguments to create many ControlRegisters.
     * @example
     * // Create many ControlRegisters
     * const controlRegister = await prisma.controlRegister.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ControlRegisters and only return the `id`
     * const controlRegisterWithIdOnly = await prisma.controlRegister.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ControlRegisterCreateManyAndReturnArgs>(args?: SelectSubset<T, ControlRegisterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ControlRegister.
     * @param {ControlRegisterDeleteArgs} args - Arguments to delete one ControlRegister.
     * @example
     * // Delete one ControlRegister
     * const ControlRegister = await prisma.controlRegister.delete({
     *   where: {
     *     // ... filter to delete one ControlRegister
     *   }
     * })
     * 
     */
    delete<T extends ControlRegisterDeleteArgs>(args: SelectSubset<T, ControlRegisterDeleteArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ControlRegister.
     * @param {ControlRegisterUpdateArgs} args - Arguments to update one ControlRegister.
     * @example
     * // Update one ControlRegister
     * const controlRegister = await prisma.controlRegister.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ControlRegisterUpdateArgs>(args: SelectSubset<T, ControlRegisterUpdateArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ControlRegisters.
     * @param {ControlRegisterDeleteManyArgs} args - Arguments to filter ControlRegisters to delete.
     * @example
     * // Delete a few ControlRegisters
     * const { count } = await prisma.controlRegister.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ControlRegisterDeleteManyArgs>(args?: SelectSubset<T, ControlRegisterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ControlRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ControlRegisters
     * const controlRegister = await prisma.controlRegister.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ControlRegisterUpdateManyArgs>(args: SelectSubset<T, ControlRegisterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ControlRegisters and returns the data updated in the database.
     * @param {ControlRegisterUpdateManyAndReturnArgs} args - Arguments to update many ControlRegisters.
     * @example
     * // Update many ControlRegisters
     * const controlRegister = await prisma.controlRegister.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ControlRegisters and only return the `id`
     * const controlRegisterWithIdOnly = await prisma.controlRegister.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ControlRegisterUpdateManyAndReturnArgs>(args: SelectSubset<T, ControlRegisterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ControlRegister.
     * @param {ControlRegisterUpsertArgs} args - Arguments to update or create a ControlRegister.
     * @example
     * // Update or create a ControlRegister
     * const controlRegister = await prisma.controlRegister.upsert({
     *   create: {
     *     // ... data to create a ControlRegister
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ControlRegister we want to update
     *   }
     * })
     */
    upsert<T extends ControlRegisterUpsertArgs>(args: SelectSubset<T, ControlRegisterUpsertArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ControlRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterCountArgs} args - Arguments to filter ControlRegisters to count.
     * @example
     * // Count the number of ControlRegisters
     * const count = await prisma.controlRegister.count({
     *   where: {
     *     // ... the filter for the ControlRegisters we want to count
     *   }
     * })
    **/
    count<T extends ControlRegisterCountArgs>(
      args?: Subset<T, ControlRegisterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ControlRegisterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ControlRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ControlRegisterAggregateArgs>(args: Subset<T, ControlRegisterAggregateArgs>): Prisma.PrismaPromise<GetControlRegisterAggregateType<T>>

    /**
     * Group by ControlRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlRegisterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ControlRegisterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ControlRegisterGroupByArgs['orderBy'] }
        : { orderBy?: ControlRegisterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ControlRegisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetControlRegisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ControlRegister model
   */
  readonly fields: ControlRegisterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ControlRegister.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ControlRegisterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    certificates<T extends ControlRegister$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, ControlRegister$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ControlRegister model
   */
  interface ControlRegisterFieldRefs {
    readonly id: FieldRef<"ControlRegister", 'Int'>
    readonly userId: FieldRef<"ControlRegister", 'Int'>
    readonly agente: FieldRef<"ControlRegister", 'String'>
    readonly fecha: FieldRef<"ControlRegister", 'DateTime'>
    readonly lugar: FieldRef<"ControlRegister", 'String'>
    readonly conductor_nombre: FieldRef<"ControlRegister", 'String'>
    readonly licencia_tipo: FieldRef<"ControlRegister", 'String'>
    readonly licencia_numero: FieldRef<"ControlRegister", 'String'>
    readonly licencia_vencimiento: FieldRef<"ControlRegister", 'DateTime'>
    readonly empresa_select: FieldRef<"ControlRegister", 'String'>
    readonly dominio: FieldRef<"ControlRegister", 'String'>
    readonly interno: FieldRef<"ControlRegister", 'String'>
    readonly c_matriculacion_venc: FieldRef<"ControlRegister", 'DateTime'>
    readonly c_matriculacion_cert: FieldRef<"ControlRegister", 'String'>
    readonly seguro_venc: FieldRef<"ControlRegister", 'DateTime'>
    readonly seguro_cert: FieldRef<"ControlRegister", 'String'>
    readonly rto_venc: FieldRef<"ControlRegister", 'DateTime'>
    readonly rto_cert: FieldRef<"ControlRegister", 'String'>
    readonly tacografo_venc: FieldRef<"ControlRegister", 'DateTime'>
    readonly tacografo_cert: FieldRef<"ControlRegister", 'String'>
    readonly createdAt: FieldRef<"ControlRegister", 'DateTime'>
    readonly updatedAt: FieldRef<"ControlRegister", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ControlRegister findUnique
   */
  export type ControlRegisterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * Filter, which ControlRegister to fetch.
     */
    where: ControlRegisterWhereUniqueInput
  }

  /**
   * ControlRegister findUniqueOrThrow
   */
  export type ControlRegisterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * Filter, which ControlRegister to fetch.
     */
    where: ControlRegisterWhereUniqueInput
  }

  /**
   * ControlRegister findFirst
   */
  export type ControlRegisterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * Filter, which ControlRegister to fetch.
     */
    where?: ControlRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlRegisters to fetch.
     */
    orderBy?: ControlRegisterOrderByWithRelationInput | ControlRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlRegisters.
     */
    cursor?: ControlRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlRegisters.
     */
    distinct?: ControlRegisterScalarFieldEnum | ControlRegisterScalarFieldEnum[]
  }

  /**
   * ControlRegister findFirstOrThrow
   */
  export type ControlRegisterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * Filter, which ControlRegister to fetch.
     */
    where?: ControlRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlRegisters to fetch.
     */
    orderBy?: ControlRegisterOrderByWithRelationInput | ControlRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlRegisters.
     */
    cursor?: ControlRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlRegisters.
     */
    distinct?: ControlRegisterScalarFieldEnum | ControlRegisterScalarFieldEnum[]
  }

  /**
   * ControlRegister findMany
   */
  export type ControlRegisterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * Filter, which ControlRegisters to fetch.
     */
    where?: ControlRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlRegisters to fetch.
     */
    orderBy?: ControlRegisterOrderByWithRelationInput | ControlRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ControlRegisters.
     */
    cursor?: ControlRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlRegisters.
     */
    skip?: number
    distinct?: ControlRegisterScalarFieldEnum | ControlRegisterScalarFieldEnum[]
  }

  /**
   * ControlRegister create
   */
  export type ControlRegisterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * The data needed to create a ControlRegister.
     */
    data: XOR<ControlRegisterCreateInput, ControlRegisterUncheckedCreateInput>
  }

  /**
   * ControlRegister createMany
   */
  export type ControlRegisterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ControlRegisters.
     */
    data: ControlRegisterCreateManyInput | ControlRegisterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ControlRegister createManyAndReturn
   */
  export type ControlRegisterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * The data used to create many ControlRegisters.
     */
    data: ControlRegisterCreateManyInput | ControlRegisterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ControlRegister update
   */
  export type ControlRegisterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * The data needed to update a ControlRegister.
     */
    data: XOR<ControlRegisterUpdateInput, ControlRegisterUncheckedUpdateInput>
    /**
     * Choose, which ControlRegister to update.
     */
    where: ControlRegisterWhereUniqueInput
  }

  /**
   * ControlRegister updateMany
   */
  export type ControlRegisterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ControlRegisters.
     */
    data: XOR<ControlRegisterUpdateManyMutationInput, ControlRegisterUncheckedUpdateManyInput>
    /**
     * Filter which ControlRegisters to update
     */
    where?: ControlRegisterWhereInput
    /**
     * Limit how many ControlRegisters to update.
     */
    limit?: number
  }

  /**
   * ControlRegister updateManyAndReturn
   */
  export type ControlRegisterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * The data used to update ControlRegisters.
     */
    data: XOR<ControlRegisterUpdateManyMutationInput, ControlRegisterUncheckedUpdateManyInput>
    /**
     * Filter which ControlRegisters to update
     */
    where?: ControlRegisterWhereInput
    /**
     * Limit how many ControlRegisters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ControlRegister upsert
   */
  export type ControlRegisterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * The filter to search for the ControlRegister to update in case it exists.
     */
    where: ControlRegisterWhereUniqueInput
    /**
     * In case the ControlRegister found by the `where` argument doesn't exist, create a new ControlRegister with this data.
     */
    create: XOR<ControlRegisterCreateInput, ControlRegisterUncheckedCreateInput>
    /**
     * In case the ControlRegister was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ControlRegisterUpdateInput, ControlRegisterUncheckedUpdateInput>
  }

  /**
   * ControlRegister delete
   */
  export type ControlRegisterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
    /**
     * Filter which ControlRegister to delete.
     */
    where: ControlRegisterWhereUniqueInput
  }

  /**
   * ControlRegister deleteMany
   */
  export type ControlRegisterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlRegisters to delete
     */
    where?: ControlRegisterWhereInput
    /**
     * Limit how many ControlRegisters to delete.
     */
    limit?: number
  }

  /**
   * ControlRegister.certificates
   */
  export type ControlRegister$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    where?: CertificateDocumentWhereInput
    orderBy?: CertificateDocumentOrderByWithRelationInput | CertificateDocumentOrderByWithRelationInput[]
    cursor?: CertificateDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateDocumentScalarFieldEnum | CertificateDocumentScalarFieldEnum[]
  }

  /**
   * ControlRegister without action
   */
  export type ControlRegisterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlRegister
     */
    select?: ControlRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ControlRegister
     */
    omit?: ControlRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlRegisterInclude<ExtArgs> | null
  }


  /**
   * Model CertificateDocument
   */

  export type AggregateCertificateDocument = {
    _count: CertificateDocumentCountAggregateOutputType | null
    _avg: CertificateDocumentAvgAggregateOutputType | null
    _sum: CertificateDocumentSumAggregateOutputType | null
    _min: CertificateDocumentMinAggregateOutputType | null
    _max: CertificateDocumentMaxAggregateOutputType | null
  }

  export type CertificateDocumentAvgAggregateOutputType = {
    id: number | null
    controlId: number | null
    fileSize: number | null
  }

  export type CertificateDocumentSumAggregateOutputType = {
    id: number | null
    controlId: number | null
    fileSize: number | null
  }

  export type CertificateDocumentMinAggregateOutputType = {
    id: number | null
    controlId: number | null
    certificateType: $Enums.CertificateType | null
    certificateNumber: string | null
    publicId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    description: string | null
    uploadedAt: Date | null
  }

  export type CertificateDocumentMaxAggregateOutputType = {
    id: number | null
    controlId: number | null
    certificateType: $Enums.CertificateType | null
    certificateNumber: string | null
    publicId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    description: string | null
    uploadedAt: Date | null
  }

  export type CertificateDocumentCountAggregateOutputType = {
    id: number
    controlId: number
    certificateType: number
    certificateNumber: number
    publicId: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    description: number
    uploadedAt: number
    _all: number
  }


  export type CertificateDocumentAvgAggregateInputType = {
    id?: true
    controlId?: true
    fileSize?: true
  }

  export type CertificateDocumentSumAggregateInputType = {
    id?: true
    controlId?: true
    fileSize?: true
  }

  export type CertificateDocumentMinAggregateInputType = {
    id?: true
    controlId?: true
    certificateType?: true
    certificateNumber?: true
    publicId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    description?: true
    uploadedAt?: true
  }

  export type CertificateDocumentMaxAggregateInputType = {
    id?: true
    controlId?: true
    certificateType?: true
    certificateNumber?: true
    publicId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    description?: true
    uploadedAt?: true
  }

  export type CertificateDocumentCountAggregateInputType = {
    id?: true
    controlId?: true
    certificateType?: true
    certificateNumber?: true
    publicId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    description?: true
    uploadedAt?: true
    _all?: true
  }

  export type CertificateDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificateDocument to aggregate.
     */
    where?: CertificateDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateDocuments to fetch.
     */
    orderBy?: CertificateDocumentOrderByWithRelationInput | CertificateDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CertificateDocuments
    **/
    _count?: true | CertificateDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateDocumentMaxAggregateInputType
  }

  export type GetCertificateDocumentAggregateType<T extends CertificateDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificateDocument[P]>
      : GetScalarType<T[P], AggregateCertificateDocument[P]>
  }




  export type CertificateDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateDocumentWhereInput
    orderBy?: CertificateDocumentOrderByWithAggregationInput | CertificateDocumentOrderByWithAggregationInput[]
    by: CertificateDocumentScalarFieldEnum[] | CertificateDocumentScalarFieldEnum
    having?: CertificateDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateDocumentCountAggregateInputType | true
    _avg?: CertificateDocumentAvgAggregateInputType
    _sum?: CertificateDocumentSumAggregateInputType
    _min?: CertificateDocumentMinAggregateInputType
    _max?: CertificateDocumentMaxAggregateInputType
  }

  export type CertificateDocumentGroupByOutputType = {
    id: number
    controlId: number
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description: string | null
    uploadedAt: Date
    _count: CertificateDocumentCountAggregateOutputType | null
    _avg: CertificateDocumentAvgAggregateOutputType | null
    _sum: CertificateDocumentSumAggregateOutputType | null
    _min: CertificateDocumentMinAggregateOutputType | null
    _max: CertificateDocumentMaxAggregateOutputType | null
  }

  type GetCertificateDocumentGroupByPayload<T extends CertificateDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CertificateDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    controlId?: boolean
    certificateType?: boolean
    certificateNumber?: boolean
    publicId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    uploadedAt?: boolean
    control?: boolean | ControlRegisterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificateDocument"]>

  export type CertificateDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    controlId?: boolean
    certificateType?: boolean
    certificateNumber?: boolean
    publicId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    uploadedAt?: boolean
    control?: boolean | ControlRegisterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificateDocument"]>

  export type CertificateDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    controlId?: boolean
    certificateType?: boolean
    certificateNumber?: boolean
    publicId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    uploadedAt?: boolean
    control?: boolean | ControlRegisterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificateDocument"]>

  export type CertificateDocumentSelectScalar = {
    id?: boolean
    controlId?: boolean
    certificateType?: boolean
    certificateNumber?: boolean
    publicId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    uploadedAt?: boolean
  }

  export type CertificateDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "controlId" | "certificateType" | "certificateNumber" | "publicId" | "fileName" | "filePath" | "fileSize" | "mimeType" | "description" | "uploadedAt", ExtArgs["result"]["certificateDocument"]>
  export type CertificateDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    control?: boolean | ControlRegisterDefaultArgs<ExtArgs>
  }
  export type CertificateDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    control?: boolean | ControlRegisterDefaultArgs<ExtArgs>
  }
  export type CertificateDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    control?: boolean | ControlRegisterDefaultArgs<ExtArgs>
  }

  export type $CertificateDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CertificateDocument"
    objects: {
      control: Prisma.$ControlRegisterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      controlId: number
      certificateType: $Enums.CertificateType
      certificateNumber: string
      publicId: string | null
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      description: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["certificateDocument"]>
    composites: {}
  }

  type CertificateDocumentGetPayload<S extends boolean | null | undefined | CertificateDocumentDefaultArgs> = $Result.GetResult<Prisma.$CertificateDocumentPayload, S>

  type CertificateDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateDocumentCountAggregateInputType | true
    }

  export interface CertificateDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CertificateDocument'], meta: { name: 'CertificateDocument' } }
    /**
     * Find zero or one CertificateDocument that matches the filter.
     * @param {CertificateDocumentFindUniqueArgs} args - Arguments to find a CertificateDocument
     * @example
     * // Get one CertificateDocument
     * const certificateDocument = await prisma.certificateDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateDocumentFindUniqueArgs>(args: SelectSubset<T, CertificateDocumentFindUniqueArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CertificateDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateDocumentFindUniqueOrThrowArgs} args - Arguments to find a CertificateDocument
     * @example
     * // Get one CertificateDocument
     * const certificateDocument = await prisma.certificateDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificateDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentFindFirstArgs} args - Arguments to find a CertificateDocument
     * @example
     * // Get one CertificateDocument
     * const certificateDocument = await prisma.certificateDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateDocumentFindFirstArgs>(args?: SelectSubset<T, CertificateDocumentFindFirstArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificateDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentFindFirstOrThrowArgs} args - Arguments to find a CertificateDocument
     * @example
     * // Get one CertificateDocument
     * const certificateDocument = await prisma.certificateDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CertificateDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertificateDocuments
     * const certificateDocuments = await prisma.certificateDocument.findMany()
     * 
     * // Get first 10 CertificateDocuments
     * const certificateDocuments = await prisma.certificateDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateDocumentWithIdOnly = await prisma.certificateDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateDocumentFindManyArgs>(args?: SelectSubset<T, CertificateDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CertificateDocument.
     * @param {CertificateDocumentCreateArgs} args - Arguments to create a CertificateDocument.
     * @example
     * // Create one CertificateDocument
     * const CertificateDocument = await prisma.certificateDocument.create({
     *   data: {
     *     // ... data to create a CertificateDocument
     *   }
     * })
     * 
     */
    create<T extends CertificateDocumentCreateArgs>(args: SelectSubset<T, CertificateDocumentCreateArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CertificateDocuments.
     * @param {CertificateDocumentCreateManyArgs} args - Arguments to create many CertificateDocuments.
     * @example
     * // Create many CertificateDocuments
     * const certificateDocument = await prisma.certificateDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateDocumentCreateManyArgs>(args?: SelectSubset<T, CertificateDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CertificateDocuments and returns the data saved in the database.
     * @param {CertificateDocumentCreateManyAndReturnArgs} args - Arguments to create many CertificateDocuments.
     * @example
     * // Create many CertificateDocuments
     * const certificateDocument = await prisma.certificateDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CertificateDocuments and only return the `id`
     * const certificateDocumentWithIdOnly = await prisma.certificateDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CertificateDocument.
     * @param {CertificateDocumentDeleteArgs} args - Arguments to delete one CertificateDocument.
     * @example
     * // Delete one CertificateDocument
     * const CertificateDocument = await prisma.certificateDocument.delete({
     *   where: {
     *     // ... filter to delete one CertificateDocument
     *   }
     * })
     * 
     */
    delete<T extends CertificateDocumentDeleteArgs>(args: SelectSubset<T, CertificateDocumentDeleteArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CertificateDocument.
     * @param {CertificateDocumentUpdateArgs} args - Arguments to update one CertificateDocument.
     * @example
     * // Update one CertificateDocument
     * const certificateDocument = await prisma.certificateDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateDocumentUpdateArgs>(args: SelectSubset<T, CertificateDocumentUpdateArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CertificateDocuments.
     * @param {CertificateDocumentDeleteManyArgs} args - Arguments to filter CertificateDocuments to delete.
     * @example
     * // Delete a few CertificateDocuments
     * const { count } = await prisma.certificateDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDocumentDeleteManyArgs>(args?: SelectSubset<T, CertificateDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertificateDocuments
     * const certificateDocument = await prisma.certificateDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateDocumentUpdateManyArgs>(args: SelectSubset<T, CertificateDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateDocuments and returns the data updated in the database.
     * @param {CertificateDocumentUpdateManyAndReturnArgs} args - Arguments to update many CertificateDocuments.
     * @example
     * // Update many CertificateDocuments
     * const certificateDocument = await prisma.certificateDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CertificateDocuments and only return the `id`
     * const certificateDocumentWithIdOnly = await prisma.certificateDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CertificateDocument.
     * @param {CertificateDocumentUpsertArgs} args - Arguments to update or create a CertificateDocument.
     * @example
     * // Update or create a CertificateDocument
     * const certificateDocument = await prisma.certificateDocument.upsert({
     *   create: {
     *     // ... data to create a CertificateDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertificateDocument we want to update
     *   }
     * })
     */
    upsert<T extends CertificateDocumentUpsertArgs>(args: SelectSubset<T, CertificateDocumentUpsertArgs<ExtArgs>>): Prisma__CertificateDocumentClient<$Result.GetResult<Prisma.$CertificateDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CertificateDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentCountArgs} args - Arguments to filter CertificateDocuments to count.
     * @example
     * // Count the number of CertificateDocuments
     * const count = await prisma.certificateDocument.count({
     *   where: {
     *     // ... the filter for the CertificateDocuments we want to count
     *   }
     * })
    **/
    count<T extends CertificateDocumentCountArgs>(
      args?: Subset<T, CertificateDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertificateDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateDocumentAggregateArgs>(args: Subset<T, CertificateDocumentAggregateArgs>): Prisma.PrismaPromise<GetCertificateDocumentAggregateType<T>>

    /**
     * Group by CertificateDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CertificateDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CertificateDocument model
   */
  readonly fields: CertificateDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CertificateDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    control<T extends ControlRegisterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ControlRegisterDefaultArgs<ExtArgs>>): Prisma__ControlRegisterClient<$Result.GetResult<Prisma.$ControlRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CertificateDocument model
   */
  interface CertificateDocumentFieldRefs {
    readonly id: FieldRef<"CertificateDocument", 'Int'>
    readonly controlId: FieldRef<"CertificateDocument", 'Int'>
    readonly certificateType: FieldRef<"CertificateDocument", 'CertificateType'>
    readonly certificateNumber: FieldRef<"CertificateDocument", 'String'>
    readonly publicId: FieldRef<"CertificateDocument", 'String'>
    readonly fileName: FieldRef<"CertificateDocument", 'String'>
    readonly filePath: FieldRef<"CertificateDocument", 'String'>
    readonly fileSize: FieldRef<"CertificateDocument", 'Int'>
    readonly mimeType: FieldRef<"CertificateDocument", 'String'>
    readonly description: FieldRef<"CertificateDocument", 'String'>
    readonly uploadedAt: FieldRef<"CertificateDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CertificateDocument findUnique
   */
  export type CertificateDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CertificateDocument to fetch.
     */
    where: CertificateDocumentWhereUniqueInput
  }

  /**
   * CertificateDocument findUniqueOrThrow
   */
  export type CertificateDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CertificateDocument to fetch.
     */
    where: CertificateDocumentWhereUniqueInput
  }

  /**
   * CertificateDocument findFirst
   */
  export type CertificateDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CertificateDocument to fetch.
     */
    where?: CertificateDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateDocuments to fetch.
     */
    orderBy?: CertificateDocumentOrderByWithRelationInput | CertificateDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateDocuments.
     */
    cursor?: CertificateDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateDocuments.
     */
    distinct?: CertificateDocumentScalarFieldEnum | CertificateDocumentScalarFieldEnum[]
  }

  /**
   * CertificateDocument findFirstOrThrow
   */
  export type CertificateDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CertificateDocument to fetch.
     */
    where?: CertificateDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateDocuments to fetch.
     */
    orderBy?: CertificateDocumentOrderByWithRelationInput | CertificateDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateDocuments.
     */
    cursor?: CertificateDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateDocuments.
     */
    distinct?: CertificateDocumentScalarFieldEnum | CertificateDocumentScalarFieldEnum[]
  }

  /**
   * CertificateDocument findMany
   */
  export type CertificateDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CertificateDocuments to fetch.
     */
    where?: CertificateDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateDocuments to fetch.
     */
    orderBy?: CertificateDocumentOrderByWithRelationInput | CertificateDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CertificateDocuments.
     */
    cursor?: CertificateDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateDocuments.
     */
    skip?: number
    distinct?: CertificateDocumentScalarFieldEnum | CertificateDocumentScalarFieldEnum[]
  }

  /**
   * CertificateDocument create
   */
  export type CertificateDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CertificateDocument.
     */
    data: XOR<CertificateDocumentCreateInput, CertificateDocumentUncheckedCreateInput>
  }

  /**
   * CertificateDocument createMany
   */
  export type CertificateDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CertificateDocuments.
     */
    data: CertificateDocumentCreateManyInput | CertificateDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificateDocument createManyAndReturn
   */
  export type CertificateDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many CertificateDocuments.
     */
    data: CertificateDocumentCreateManyInput | CertificateDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CertificateDocument update
   */
  export type CertificateDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CertificateDocument.
     */
    data: XOR<CertificateDocumentUpdateInput, CertificateDocumentUncheckedUpdateInput>
    /**
     * Choose, which CertificateDocument to update.
     */
    where: CertificateDocumentWhereUniqueInput
  }

  /**
   * CertificateDocument updateMany
   */
  export type CertificateDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CertificateDocuments.
     */
    data: XOR<CertificateDocumentUpdateManyMutationInput, CertificateDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CertificateDocuments to update
     */
    where?: CertificateDocumentWhereInput
    /**
     * Limit how many CertificateDocuments to update.
     */
    limit?: number
  }

  /**
   * CertificateDocument updateManyAndReturn
   */
  export type CertificateDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * The data used to update CertificateDocuments.
     */
    data: XOR<CertificateDocumentUpdateManyMutationInput, CertificateDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CertificateDocuments to update
     */
    where?: CertificateDocumentWhereInput
    /**
     * Limit how many CertificateDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CertificateDocument upsert
   */
  export type CertificateDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CertificateDocument to update in case it exists.
     */
    where: CertificateDocumentWhereUniqueInput
    /**
     * In case the CertificateDocument found by the `where` argument doesn't exist, create a new CertificateDocument with this data.
     */
    create: XOR<CertificateDocumentCreateInput, CertificateDocumentUncheckedCreateInput>
    /**
     * In case the CertificateDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateDocumentUpdateInput, CertificateDocumentUncheckedUpdateInput>
  }

  /**
   * CertificateDocument delete
   */
  export type CertificateDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
    /**
     * Filter which CertificateDocument to delete.
     */
    where: CertificateDocumentWhereUniqueInput
  }

  /**
   * CertificateDocument deleteMany
   */
  export type CertificateDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificateDocuments to delete
     */
    where?: CertificateDocumentWhereInput
    /**
     * Limit how many CertificateDocuments to delete.
     */
    limit?: number
  }

  /**
   * CertificateDocument without action
   */
  export type CertificateDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateDocument
     */
    select?: CertificateDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateDocument
     */
    omit?: CertificateDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateDocumentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserConfigScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    pdfGenerate: 'pdfGenerate',
    showAllRegistries: 'showAllRegistries',
    cacheRegistries: 'cacheRegistries',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserConfigScalarFieldEnum = (typeof UserConfigScalarFieldEnum)[keyof typeof UserConfigScalarFieldEnum]


  export const ControlRegisterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agente: 'agente',
    fecha: 'fecha',
    lugar: 'lugar',
    conductor_nombre: 'conductor_nombre',
    licencia_tipo: 'licencia_tipo',
    licencia_numero: 'licencia_numero',
    licencia_vencimiento: 'licencia_vencimiento',
    empresa_select: 'empresa_select',
    dominio: 'dominio',
    interno: 'interno',
    c_matriculacion_venc: 'c_matriculacion_venc',
    c_matriculacion_cert: 'c_matriculacion_cert',
    seguro_venc: 'seguro_venc',
    seguro_cert: 'seguro_cert',
    rto_venc: 'rto_venc',
    rto_cert: 'rto_cert',
    tacografo_venc: 'tacografo_venc',
    tacografo_cert: 'tacografo_cert',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ControlRegisterScalarFieldEnum = (typeof ControlRegisterScalarFieldEnum)[keyof typeof ControlRegisterScalarFieldEnum]


  export const CertificateDocumentScalarFieldEnum: {
    id: 'id',
    controlId: 'controlId',
    certificateType: 'certificateType',
    certificateNumber: 'certificateNumber',
    publicId: 'publicId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    description: 'description',
    uploadedAt: 'uploadedAt'
  };

  export type CertificateDocumentScalarFieldEnum = (typeof CertificateDocumentScalarFieldEnum)[keyof typeof CertificateDocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CertificateType'
   */
  export type EnumCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificateType'>
    


  /**
   * Reference to a field of type 'CertificateType[]'
   */
  export type ListEnumCertificateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CertificateType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    config?: XOR<UserConfigNullableScalarRelationFilter, UserConfigWhereInput> | null
    controlRegister?: ControlRegisterListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    config?: UserConfigOrderByWithRelationInput
    controlRegister?: ControlRegisterOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    config?: XOR<UserConfigNullableScalarRelationFilter, UserConfigWhereInput> | null
    controlRegister?: ControlRegisterListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserConfigWhereInput = {
    AND?: UserConfigWhereInput | UserConfigWhereInput[]
    OR?: UserConfigWhereInput[]
    NOT?: UserConfigWhereInput | UserConfigWhereInput[]
    id?: StringFilter<"UserConfig"> | string
    userId?: IntFilter<"UserConfig"> | number
    pdfGenerate?: BoolFilter<"UserConfig"> | boolean
    showAllRegistries?: BoolFilter<"UserConfig"> | boolean
    cacheRegistries?: BoolFilter<"UserConfig"> | boolean
    createdAt?: DateTimeFilter<"UserConfig"> | Date | string
    updatedAt?: DateTimeFilter<"UserConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserConfigOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfGenerate?: SortOrder
    showAllRegistries?: SortOrder
    cacheRegistries?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: number
    AND?: UserConfigWhereInput | UserConfigWhereInput[]
    OR?: UserConfigWhereInput[]
    NOT?: UserConfigWhereInput | UserConfigWhereInput[]
    pdfGenerate?: BoolFilter<"UserConfig"> | boolean
    showAllRegistries?: BoolFilter<"UserConfig"> | boolean
    cacheRegistries?: BoolFilter<"UserConfig"> | boolean
    createdAt?: DateTimeFilter<"UserConfig"> | Date | string
    updatedAt?: DateTimeFilter<"UserConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserConfigOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfGenerate?: SortOrder
    showAllRegistries?: SortOrder
    cacheRegistries?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserConfigCountOrderByAggregateInput
    _avg?: UserConfigAvgOrderByAggregateInput
    _max?: UserConfigMaxOrderByAggregateInput
    _min?: UserConfigMinOrderByAggregateInput
    _sum?: UserConfigSumOrderByAggregateInput
  }

  export type UserConfigScalarWhereWithAggregatesInput = {
    AND?: UserConfigScalarWhereWithAggregatesInput | UserConfigScalarWhereWithAggregatesInput[]
    OR?: UserConfigScalarWhereWithAggregatesInput[]
    NOT?: UserConfigScalarWhereWithAggregatesInput | UserConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserConfig"> | string
    userId?: IntWithAggregatesFilter<"UserConfig"> | number
    pdfGenerate?: BoolWithAggregatesFilter<"UserConfig"> | boolean
    showAllRegistries?: BoolWithAggregatesFilter<"UserConfig"> | boolean
    cacheRegistries?: BoolWithAggregatesFilter<"UserConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserConfig"> | Date | string
  }

  export type ControlRegisterWhereInput = {
    AND?: ControlRegisterWhereInput | ControlRegisterWhereInput[]
    OR?: ControlRegisterWhereInput[]
    NOT?: ControlRegisterWhereInput | ControlRegisterWhereInput[]
    id?: IntFilter<"ControlRegister"> | number
    userId?: IntFilter<"ControlRegister"> | number
    agente?: StringFilter<"ControlRegister"> | string
    fecha?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    lugar?: StringFilter<"ControlRegister"> | string
    conductor_nombre?: StringFilter<"ControlRegister"> | string
    licencia_tipo?: StringFilter<"ControlRegister"> | string
    licencia_numero?: StringFilter<"ControlRegister"> | string
    licencia_vencimiento?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    empresa_select?: StringFilter<"ControlRegister"> | string
    dominio?: StringFilter<"ControlRegister"> | string
    interno?: StringNullableFilter<"ControlRegister"> | string | null
    c_matriculacion_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    c_matriculacion_cert?: StringNullableFilter<"ControlRegister"> | string | null
    seguro_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    seguro_cert?: StringNullableFilter<"ControlRegister"> | string | null
    rto_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    rto_cert?: StringNullableFilter<"ControlRegister"> | string | null
    tacografo_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    tacografo_cert?: StringNullableFilter<"ControlRegister"> | string | null
    createdAt?: DateTimeFilter<"ControlRegister"> | Date | string
    updatedAt?: DateTimeFilter<"ControlRegister"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    certificates?: CertificateDocumentListRelationFilter
  }

  export type ControlRegisterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agente?: SortOrder
    fecha?: SortOrderInput | SortOrder
    lugar?: SortOrder
    conductor_nombre?: SortOrder
    licencia_tipo?: SortOrder
    licencia_numero?: SortOrder
    licencia_vencimiento?: SortOrderInput | SortOrder
    empresa_select?: SortOrder
    dominio?: SortOrder
    interno?: SortOrderInput | SortOrder
    c_matriculacion_venc?: SortOrderInput | SortOrder
    c_matriculacion_cert?: SortOrderInput | SortOrder
    seguro_venc?: SortOrderInput | SortOrder
    seguro_cert?: SortOrderInput | SortOrder
    rto_venc?: SortOrderInput | SortOrder
    rto_cert?: SortOrderInput | SortOrder
    tacografo_venc?: SortOrderInput | SortOrder
    tacografo_cert?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    certificates?: CertificateDocumentOrderByRelationAggregateInput
  }

  export type ControlRegisterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ControlRegisterWhereInput | ControlRegisterWhereInput[]
    OR?: ControlRegisterWhereInput[]
    NOT?: ControlRegisterWhereInput | ControlRegisterWhereInput[]
    userId?: IntFilter<"ControlRegister"> | number
    agente?: StringFilter<"ControlRegister"> | string
    fecha?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    lugar?: StringFilter<"ControlRegister"> | string
    conductor_nombre?: StringFilter<"ControlRegister"> | string
    licencia_tipo?: StringFilter<"ControlRegister"> | string
    licencia_numero?: StringFilter<"ControlRegister"> | string
    licencia_vencimiento?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    empresa_select?: StringFilter<"ControlRegister"> | string
    dominio?: StringFilter<"ControlRegister"> | string
    interno?: StringNullableFilter<"ControlRegister"> | string | null
    c_matriculacion_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    c_matriculacion_cert?: StringNullableFilter<"ControlRegister"> | string | null
    seguro_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    seguro_cert?: StringNullableFilter<"ControlRegister"> | string | null
    rto_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    rto_cert?: StringNullableFilter<"ControlRegister"> | string | null
    tacografo_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    tacografo_cert?: StringNullableFilter<"ControlRegister"> | string | null
    createdAt?: DateTimeFilter<"ControlRegister"> | Date | string
    updatedAt?: DateTimeFilter<"ControlRegister"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    certificates?: CertificateDocumentListRelationFilter
  }, "id">

  export type ControlRegisterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agente?: SortOrder
    fecha?: SortOrderInput | SortOrder
    lugar?: SortOrder
    conductor_nombre?: SortOrder
    licencia_tipo?: SortOrder
    licencia_numero?: SortOrder
    licencia_vencimiento?: SortOrderInput | SortOrder
    empresa_select?: SortOrder
    dominio?: SortOrder
    interno?: SortOrderInput | SortOrder
    c_matriculacion_venc?: SortOrderInput | SortOrder
    c_matriculacion_cert?: SortOrderInput | SortOrder
    seguro_venc?: SortOrderInput | SortOrder
    seguro_cert?: SortOrderInput | SortOrder
    rto_venc?: SortOrderInput | SortOrder
    rto_cert?: SortOrderInput | SortOrder
    tacografo_venc?: SortOrderInput | SortOrder
    tacografo_cert?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ControlRegisterCountOrderByAggregateInput
    _avg?: ControlRegisterAvgOrderByAggregateInput
    _max?: ControlRegisterMaxOrderByAggregateInput
    _min?: ControlRegisterMinOrderByAggregateInput
    _sum?: ControlRegisterSumOrderByAggregateInput
  }

  export type ControlRegisterScalarWhereWithAggregatesInput = {
    AND?: ControlRegisterScalarWhereWithAggregatesInput | ControlRegisterScalarWhereWithAggregatesInput[]
    OR?: ControlRegisterScalarWhereWithAggregatesInput[]
    NOT?: ControlRegisterScalarWhereWithAggregatesInput | ControlRegisterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ControlRegister"> | number
    userId?: IntWithAggregatesFilter<"ControlRegister"> | number
    agente?: StringWithAggregatesFilter<"ControlRegister"> | string
    fecha?: DateTimeNullableWithAggregatesFilter<"ControlRegister"> | Date | string | null
    lugar?: StringWithAggregatesFilter<"ControlRegister"> | string
    conductor_nombre?: StringWithAggregatesFilter<"ControlRegister"> | string
    licencia_tipo?: StringWithAggregatesFilter<"ControlRegister"> | string
    licencia_numero?: StringWithAggregatesFilter<"ControlRegister"> | string
    licencia_vencimiento?: DateTimeNullableWithAggregatesFilter<"ControlRegister"> | Date | string | null
    empresa_select?: StringWithAggregatesFilter<"ControlRegister"> | string
    dominio?: StringWithAggregatesFilter<"ControlRegister"> | string
    interno?: StringNullableWithAggregatesFilter<"ControlRegister"> | string | null
    c_matriculacion_venc?: DateTimeNullableWithAggregatesFilter<"ControlRegister"> | Date | string | null
    c_matriculacion_cert?: StringNullableWithAggregatesFilter<"ControlRegister"> | string | null
    seguro_venc?: DateTimeNullableWithAggregatesFilter<"ControlRegister"> | Date | string | null
    seguro_cert?: StringNullableWithAggregatesFilter<"ControlRegister"> | string | null
    rto_venc?: DateTimeNullableWithAggregatesFilter<"ControlRegister"> | Date | string | null
    rto_cert?: StringNullableWithAggregatesFilter<"ControlRegister"> | string | null
    tacografo_venc?: DateTimeNullableWithAggregatesFilter<"ControlRegister"> | Date | string | null
    tacografo_cert?: StringNullableWithAggregatesFilter<"ControlRegister"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ControlRegister"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ControlRegister"> | Date | string
  }

  export type CertificateDocumentWhereInput = {
    AND?: CertificateDocumentWhereInput | CertificateDocumentWhereInput[]
    OR?: CertificateDocumentWhereInput[]
    NOT?: CertificateDocumentWhereInput | CertificateDocumentWhereInput[]
    id?: IntFilter<"CertificateDocument"> | number
    controlId?: IntFilter<"CertificateDocument"> | number
    certificateType?: EnumCertificateTypeFilter<"CertificateDocument"> | $Enums.CertificateType
    certificateNumber?: StringFilter<"CertificateDocument"> | string
    publicId?: StringNullableFilter<"CertificateDocument"> | string | null
    fileName?: StringFilter<"CertificateDocument"> | string
    filePath?: StringFilter<"CertificateDocument"> | string
    fileSize?: IntFilter<"CertificateDocument"> | number
    mimeType?: StringFilter<"CertificateDocument"> | string
    description?: StringNullableFilter<"CertificateDocument"> | string | null
    uploadedAt?: DateTimeFilter<"CertificateDocument"> | Date | string
    control?: XOR<ControlRegisterScalarRelationFilter, ControlRegisterWhereInput>
  }

  export type CertificateDocumentOrderByWithRelationInput = {
    id?: SortOrder
    controlId?: SortOrder
    certificateType?: SortOrder
    certificateNumber?: SortOrder
    publicId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    control?: ControlRegisterOrderByWithRelationInput
  }

  export type CertificateDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    controlId_certificateType?: CertificateDocumentControlIdCertificateTypeCompoundUniqueInput
    AND?: CertificateDocumentWhereInput | CertificateDocumentWhereInput[]
    OR?: CertificateDocumentWhereInput[]
    NOT?: CertificateDocumentWhereInput | CertificateDocumentWhereInput[]
    controlId?: IntFilter<"CertificateDocument"> | number
    certificateType?: EnumCertificateTypeFilter<"CertificateDocument"> | $Enums.CertificateType
    certificateNumber?: StringFilter<"CertificateDocument"> | string
    publicId?: StringNullableFilter<"CertificateDocument"> | string | null
    fileName?: StringFilter<"CertificateDocument"> | string
    filePath?: StringFilter<"CertificateDocument"> | string
    fileSize?: IntFilter<"CertificateDocument"> | number
    mimeType?: StringFilter<"CertificateDocument"> | string
    description?: StringNullableFilter<"CertificateDocument"> | string | null
    uploadedAt?: DateTimeFilter<"CertificateDocument"> | Date | string
    control?: XOR<ControlRegisterScalarRelationFilter, ControlRegisterWhereInput>
  }, "id" | "controlId_certificateType">

  export type CertificateDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    controlId?: SortOrder
    certificateType?: SortOrder
    certificateNumber?: SortOrder
    publicId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: CertificateDocumentCountOrderByAggregateInput
    _avg?: CertificateDocumentAvgOrderByAggregateInput
    _max?: CertificateDocumentMaxOrderByAggregateInput
    _min?: CertificateDocumentMinOrderByAggregateInput
    _sum?: CertificateDocumentSumOrderByAggregateInput
  }

  export type CertificateDocumentScalarWhereWithAggregatesInput = {
    AND?: CertificateDocumentScalarWhereWithAggregatesInput | CertificateDocumentScalarWhereWithAggregatesInput[]
    OR?: CertificateDocumentScalarWhereWithAggregatesInput[]
    NOT?: CertificateDocumentScalarWhereWithAggregatesInput | CertificateDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CertificateDocument"> | number
    controlId?: IntWithAggregatesFilter<"CertificateDocument"> | number
    certificateType?: EnumCertificateTypeWithAggregatesFilter<"CertificateDocument"> | $Enums.CertificateType
    certificateNumber?: StringWithAggregatesFilter<"CertificateDocument"> | string
    publicId?: StringNullableWithAggregatesFilter<"CertificateDocument"> | string | null
    fileName?: StringWithAggregatesFilter<"CertificateDocument"> | string
    filePath?: StringWithAggregatesFilter<"CertificateDocument"> | string
    fileSize?: IntWithAggregatesFilter<"CertificateDocument"> | number
    mimeType?: StringWithAggregatesFilter<"CertificateDocument"> | string
    description?: StringNullableWithAggregatesFilter<"CertificateDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"CertificateDocument"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    config?: UserConfigCreateNestedOneWithoutUserInput
    controlRegister?: ControlRegisterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    config?: UserConfigUncheckedCreateNestedOneWithoutUserInput
    controlRegister?: ControlRegisterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: UserConfigUpdateOneWithoutUserNestedInput
    controlRegister?: ControlRegisterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: UserConfigUncheckedUpdateOneWithoutUserNestedInput
    controlRegister?: ControlRegisterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConfigCreateInput = {
    id?: string
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConfigInput
  }

  export type UserConfigUncheckedCreateInput = {
    id?: string
    userId: number
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfGenerate?: BoolFieldUpdateOperationsInput | boolean
    showAllRegistries?: BoolFieldUpdateOperationsInput | boolean
    cacheRegistries?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConfigNestedInput
  }

  export type UserConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    pdfGenerate?: BoolFieldUpdateOperationsInput | boolean
    showAllRegistries?: BoolFieldUpdateOperationsInput | boolean
    cacheRegistries?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConfigCreateManyInput = {
    id?: string
    userId: number
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfGenerate?: BoolFieldUpdateOperationsInput | boolean
    showAllRegistries?: BoolFieldUpdateOperationsInput | boolean
    cacheRegistries?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    pdfGenerate?: BoolFieldUpdateOperationsInput | boolean
    showAllRegistries?: BoolFieldUpdateOperationsInput | boolean
    cacheRegistries?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlRegisterCreateInput = {
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutControlRegisterInput
    certificates?: CertificateDocumentCreateNestedManyWithoutControlInput
  }

  export type ControlRegisterUncheckedCreateInput = {
    id?: number
    userId: number
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateDocumentUncheckedCreateNestedManyWithoutControlInput
  }

  export type ControlRegisterUpdateInput = {
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutControlRegisterNestedInput
    certificates?: CertificateDocumentUpdateManyWithoutControlNestedInput
  }

  export type ControlRegisterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateDocumentUncheckedUpdateManyWithoutControlNestedInput
  }

  export type ControlRegisterCreateManyInput = {
    id?: number
    userId: number
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlRegisterUpdateManyMutationInput = {
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlRegisterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateDocumentCreateInput = {
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description?: string | null
    uploadedAt?: Date | string
    control: ControlRegisterCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateDocumentUncheckedCreateInput = {
    id?: number
    controlId: number
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description?: string | null
    uploadedAt?: Date | string
  }

  export type CertificateDocumentUpdateInput = {
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    control?: ControlRegisterUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    controlId?: IntFieldUpdateOperationsInput | number
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateDocumentCreateManyInput = {
    id?: number
    controlId: number
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description?: string | null
    uploadedAt?: Date | string
  }

  export type CertificateDocumentUpdateManyMutationInput = {
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    controlId?: IntFieldUpdateOperationsInput | number
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserConfigNullableScalarRelationFilter = {
    is?: UserConfigWhereInput | null
    isNot?: UserConfigWhereInput | null
  }

  export type ControlRegisterListRelationFilter = {
    every?: ControlRegisterWhereInput
    some?: ControlRegisterWhereInput
    none?: ControlRegisterWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ControlRegisterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserConfigCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfGenerate?: SortOrder
    showAllRegistries?: SortOrder
    cacheRegistries?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserConfigAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UserConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfGenerate?: SortOrder
    showAllRegistries?: SortOrder
    cacheRegistries?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserConfigMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfGenerate?: SortOrder
    showAllRegistries?: SortOrder
    cacheRegistries?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserConfigSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CertificateDocumentListRelationFilter = {
    every?: CertificateDocumentWhereInput
    some?: CertificateDocumentWhereInput
    none?: CertificateDocumentWhereInput
  }

  export type CertificateDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ControlRegisterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agente?: SortOrder
    fecha?: SortOrder
    lugar?: SortOrder
    conductor_nombre?: SortOrder
    licencia_tipo?: SortOrder
    licencia_numero?: SortOrder
    licencia_vencimiento?: SortOrder
    empresa_select?: SortOrder
    dominio?: SortOrder
    interno?: SortOrder
    c_matriculacion_venc?: SortOrder
    c_matriculacion_cert?: SortOrder
    seguro_venc?: SortOrder
    seguro_cert?: SortOrder
    rto_venc?: SortOrder
    rto_cert?: SortOrder
    tacografo_venc?: SortOrder
    tacografo_cert?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlRegisterAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ControlRegisterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agente?: SortOrder
    fecha?: SortOrder
    lugar?: SortOrder
    conductor_nombre?: SortOrder
    licencia_tipo?: SortOrder
    licencia_numero?: SortOrder
    licencia_vencimiento?: SortOrder
    empresa_select?: SortOrder
    dominio?: SortOrder
    interno?: SortOrder
    c_matriculacion_venc?: SortOrder
    c_matriculacion_cert?: SortOrder
    seguro_venc?: SortOrder
    seguro_cert?: SortOrder
    rto_venc?: SortOrder
    rto_cert?: SortOrder
    tacografo_venc?: SortOrder
    tacografo_cert?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlRegisterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agente?: SortOrder
    fecha?: SortOrder
    lugar?: SortOrder
    conductor_nombre?: SortOrder
    licencia_tipo?: SortOrder
    licencia_numero?: SortOrder
    licencia_vencimiento?: SortOrder
    empresa_select?: SortOrder
    dominio?: SortOrder
    interno?: SortOrder
    c_matriculacion_venc?: SortOrder
    c_matriculacion_cert?: SortOrder
    seguro_venc?: SortOrder
    seguro_cert?: SortOrder
    rto_venc?: SortOrder
    rto_cert?: SortOrder
    tacografo_venc?: SortOrder
    tacografo_cert?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlRegisterSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCertificateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeFilter<$PrismaModel> | $Enums.CertificateType
  }

  export type ControlRegisterScalarRelationFilter = {
    is?: ControlRegisterWhereInput
    isNot?: ControlRegisterWhereInput
  }

  export type CertificateDocumentControlIdCertificateTypeCompoundUniqueInput = {
    controlId: number
    certificateType: $Enums.CertificateType
  }

  export type CertificateDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    controlId?: SortOrder
    certificateType?: SortOrder
    certificateNumber?: SortOrder
    publicId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrder
    uploadedAt?: SortOrder
  }

  export type CertificateDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    controlId?: SortOrder
    fileSize?: SortOrder
  }

  export type CertificateDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    controlId?: SortOrder
    certificateType?: SortOrder
    certificateNumber?: SortOrder
    publicId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrder
    uploadedAt?: SortOrder
  }

  export type CertificateDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    controlId?: SortOrder
    certificateType?: SortOrder
    certificateNumber?: SortOrder
    publicId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrder
    uploadedAt?: SortOrder
  }

  export type CertificateDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    controlId?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumCertificateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificateTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificateTypeFilter<$PrismaModel>
  }

  export type UserConfigCreateNestedOneWithoutUserInput = {
    create?: XOR<UserConfigCreateWithoutUserInput, UserConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConfigCreateOrConnectWithoutUserInput
    connect?: UserConfigWhereUniqueInput
  }

  export type ControlRegisterCreateNestedManyWithoutUserInput = {
    create?: XOR<ControlRegisterCreateWithoutUserInput, ControlRegisterUncheckedCreateWithoutUserInput> | ControlRegisterCreateWithoutUserInput[] | ControlRegisterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ControlRegisterCreateOrConnectWithoutUserInput | ControlRegisterCreateOrConnectWithoutUserInput[]
    createMany?: ControlRegisterCreateManyUserInputEnvelope
    connect?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
  }

  export type UserConfigUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserConfigCreateWithoutUserInput, UserConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConfigCreateOrConnectWithoutUserInput
    connect?: UserConfigWhereUniqueInput
  }

  export type ControlRegisterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ControlRegisterCreateWithoutUserInput, ControlRegisterUncheckedCreateWithoutUserInput> | ControlRegisterCreateWithoutUserInput[] | ControlRegisterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ControlRegisterCreateOrConnectWithoutUserInput | ControlRegisterCreateOrConnectWithoutUserInput[]
    createMany?: ControlRegisterCreateManyUserInputEnvelope
    connect?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserConfigUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserConfigCreateWithoutUserInput, UserConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConfigCreateOrConnectWithoutUserInput
    upsert?: UserConfigUpsertWithoutUserInput
    disconnect?: UserConfigWhereInput | boolean
    delete?: UserConfigWhereInput | boolean
    connect?: UserConfigWhereUniqueInput
    update?: XOR<XOR<UserConfigUpdateToOneWithWhereWithoutUserInput, UserConfigUpdateWithoutUserInput>, UserConfigUncheckedUpdateWithoutUserInput>
  }

  export type ControlRegisterUpdateManyWithoutUserNestedInput = {
    create?: XOR<ControlRegisterCreateWithoutUserInput, ControlRegisterUncheckedCreateWithoutUserInput> | ControlRegisterCreateWithoutUserInput[] | ControlRegisterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ControlRegisterCreateOrConnectWithoutUserInput | ControlRegisterCreateOrConnectWithoutUserInput[]
    upsert?: ControlRegisterUpsertWithWhereUniqueWithoutUserInput | ControlRegisterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ControlRegisterCreateManyUserInputEnvelope
    set?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    disconnect?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    delete?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    connect?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    update?: ControlRegisterUpdateWithWhereUniqueWithoutUserInput | ControlRegisterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ControlRegisterUpdateManyWithWhereWithoutUserInput | ControlRegisterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ControlRegisterScalarWhereInput | ControlRegisterScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserConfigUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserConfigCreateWithoutUserInput, UserConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserConfigCreateOrConnectWithoutUserInput
    upsert?: UserConfigUpsertWithoutUserInput
    disconnect?: UserConfigWhereInput | boolean
    delete?: UserConfigWhereInput | boolean
    connect?: UserConfigWhereUniqueInput
    update?: XOR<XOR<UserConfigUpdateToOneWithWhereWithoutUserInput, UserConfigUpdateWithoutUserInput>, UserConfigUncheckedUpdateWithoutUserInput>
  }

  export type ControlRegisterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ControlRegisterCreateWithoutUserInput, ControlRegisterUncheckedCreateWithoutUserInput> | ControlRegisterCreateWithoutUserInput[] | ControlRegisterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ControlRegisterCreateOrConnectWithoutUserInput | ControlRegisterCreateOrConnectWithoutUserInput[]
    upsert?: ControlRegisterUpsertWithWhereUniqueWithoutUserInput | ControlRegisterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ControlRegisterCreateManyUserInputEnvelope
    set?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    disconnect?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    delete?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    connect?: ControlRegisterWhereUniqueInput | ControlRegisterWhereUniqueInput[]
    update?: ControlRegisterUpdateWithWhereUniqueWithoutUserInput | ControlRegisterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ControlRegisterUpdateManyWithWhereWithoutUserInput | ControlRegisterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ControlRegisterScalarWhereInput | ControlRegisterScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConfigInput = {
    create?: XOR<UserCreateWithoutConfigInput, UserUncheckedCreateWithoutConfigInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfigInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConfigNestedInput = {
    create?: XOR<UserCreateWithoutConfigInput, UserUncheckedCreateWithoutConfigInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfigInput
    upsert?: UserUpsertWithoutConfigInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConfigInput, UserUpdateWithoutConfigInput>, UserUncheckedUpdateWithoutConfigInput>
  }

  export type UserCreateNestedOneWithoutControlRegisterInput = {
    create?: XOR<UserCreateWithoutControlRegisterInput, UserUncheckedCreateWithoutControlRegisterInput>
    connectOrCreate?: UserCreateOrConnectWithoutControlRegisterInput
    connect?: UserWhereUniqueInput
  }

  export type CertificateDocumentCreateNestedManyWithoutControlInput = {
    create?: XOR<CertificateDocumentCreateWithoutControlInput, CertificateDocumentUncheckedCreateWithoutControlInput> | CertificateDocumentCreateWithoutControlInput[] | CertificateDocumentUncheckedCreateWithoutControlInput[]
    connectOrCreate?: CertificateDocumentCreateOrConnectWithoutControlInput | CertificateDocumentCreateOrConnectWithoutControlInput[]
    createMany?: CertificateDocumentCreateManyControlInputEnvelope
    connect?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
  }

  export type CertificateDocumentUncheckedCreateNestedManyWithoutControlInput = {
    create?: XOR<CertificateDocumentCreateWithoutControlInput, CertificateDocumentUncheckedCreateWithoutControlInput> | CertificateDocumentCreateWithoutControlInput[] | CertificateDocumentUncheckedCreateWithoutControlInput[]
    connectOrCreate?: CertificateDocumentCreateOrConnectWithoutControlInput | CertificateDocumentCreateOrConnectWithoutControlInput[]
    createMany?: CertificateDocumentCreateManyControlInputEnvelope
    connect?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutControlRegisterNestedInput = {
    create?: XOR<UserCreateWithoutControlRegisterInput, UserUncheckedCreateWithoutControlRegisterInput>
    connectOrCreate?: UserCreateOrConnectWithoutControlRegisterInput
    upsert?: UserUpsertWithoutControlRegisterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutControlRegisterInput, UserUpdateWithoutControlRegisterInput>, UserUncheckedUpdateWithoutControlRegisterInput>
  }

  export type CertificateDocumentUpdateManyWithoutControlNestedInput = {
    create?: XOR<CertificateDocumentCreateWithoutControlInput, CertificateDocumentUncheckedCreateWithoutControlInput> | CertificateDocumentCreateWithoutControlInput[] | CertificateDocumentUncheckedCreateWithoutControlInput[]
    connectOrCreate?: CertificateDocumentCreateOrConnectWithoutControlInput | CertificateDocumentCreateOrConnectWithoutControlInput[]
    upsert?: CertificateDocumentUpsertWithWhereUniqueWithoutControlInput | CertificateDocumentUpsertWithWhereUniqueWithoutControlInput[]
    createMany?: CertificateDocumentCreateManyControlInputEnvelope
    set?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    disconnect?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    delete?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    connect?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    update?: CertificateDocumentUpdateWithWhereUniqueWithoutControlInput | CertificateDocumentUpdateWithWhereUniqueWithoutControlInput[]
    updateMany?: CertificateDocumentUpdateManyWithWhereWithoutControlInput | CertificateDocumentUpdateManyWithWhereWithoutControlInput[]
    deleteMany?: CertificateDocumentScalarWhereInput | CertificateDocumentScalarWhereInput[]
  }

  export type CertificateDocumentUncheckedUpdateManyWithoutControlNestedInput = {
    create?: XOR<CertificateDocumentCreateWithoutControlInput, CertificateDocumentUncheckedCreateWithoutControlInput> | CertificateDocumentCreateWithoutControlInput[] | CertificateDocumentUncheckedCreateWithoutControlInput[]
    connectOrCreate?: CertificateDocumentCreateOrConnectWithoutControlInput | CertificateDocumentCreateOrConnectWithoutControlInput[]
    upsert?: CertificateDocumentUpsertWithWhereUniqueWithoutControlInput | CertificateDocumentUpsertWithWhereUniqueWithoutControlInput[]
    createMany?: CertificateDocumentCreateManyControlInputEnvelope
    set?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    disconnect?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    delete?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    connect?: CertificateDocumentWhereUniqueInput | CertificateDocumentWhereUniqueInput[]
    update?: CertificateDocumentUpdateWithWhereUniqueWithoutControlInput | CertificateDocumentUpdateWithWhereUniqueWithoutControlInput[]
    updateMany?: CertificateDocumentUpdateManyWithWhereWithoutControlInput | CertificateDocumentUpdateManyWithWhereWithoutControlInput[]
    deleteMany?: CertificateDocumentScalarWhereInput | CertificateDocumentScalarWhereInput[]
  }

  export type ControlRegisterCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<ControlRegisterCreateWithoutCertificatesInput, ControlRegisterUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ControlRegisterCreateOrConnectWithoutCertificatesInput
    connect?: ControlRegisterWhereUniqueInput
  }

  export type EnumCertificateTypeFieldUpdateOperationsInput = {
    set?: $Enums.CertificateType
  }

  export type ControlRegisterUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<ControlRegisterCreateWithoutCertificatesInput, ControlRegisterUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ControlRegisterCreateOrConnectWithoutCertificatesInput
    upsert?: ControlRegisterUpsertWithoutCertificatesInput
    connect?: ControlRegisterWhereUniqueInput
    update?: XOR<XOR<ControlRegisterUpdateToOneWithWhereWithoutCertificatesInput, ControlRegisterUpdateWithoutCertificatesInput>, ControlRegisterUncheckedUpdateWithoutCertificatesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCertificateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeFilter<$PrismaModel> | $Enums.CertificateType
  }

  export type NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CertificateType | EnumCertificateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CertificateType[] | ListEnumCertificateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCertificateTypeWithAggregatesFilter<$PrismaModel> | $Enums.CertificateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCertificateTypeFilter<$PrismaModel>
    _max?: NestedEnumCertificateTypeFilter<$PrismaModel>
  }

  export type UserConfigCreateWithoutUserInput = {
    id?: string
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConfigUncheckedCreateWithoutUserInput = {
    id?: string
    pdfGenerate?: boolean
    showAllRegistries?: boolean
    cacheRegistries?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserConfigCreateOrConnectWithoutUserInput = {
    where: UserConfigWhereUniqueInput
    create: XOR<UserConfigCreateWithoutUserInput, UserConfigUncheckedCreateWithoutUserInput>
  }

  export type ControlRegisterCreateWithoutUserInput = {
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateDocumentCreateNestedManyWithoutControlInput
  }

  export type ControlRegisterUncheckedCreateWithoutUserInput = {
    id?: number
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateDocumentUncheckedCreateNestedManyWithoutControlInput
  }

  export type ControlRegisterCreateOrConnectWithoutUserInput = {
    where: ControlRegisterWhereUniqueInput
    create: XOR<ControlRegisterCreateWithoutUserInput, ControlRegisterUncheckedCreateWithoutUserInput>
  }

  export type ControlRegisterCreateManyUserInputEnvelope = {
    data: ControlRegisterCreateManyUserInput | ControlRegisterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserConfigUpsertWithoutUserInput = {
    update: XOR<UserConfigUpdateWithoutUserInput, UserConfigUncheckedUpdateWithoutUserInput>
    create: XOR<UserConfigCreateWithoutUserInput, UserConfigUncheckedCreateWithoutUserInput>
    where?: UserConfigWhereInput
  }

  export type UserConfigUpdateToOneWithWhereWithoutUserInput = {
    where?: UserConfigWhereInput
    data: XOR<UserConfigUpdateWithoutUserInput, UserConfigUncheckedUpdateWithoutUserInput>
  }

  export type UserConfigUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfGenerate?: BoolFieldUpdateOperationsInput | boolean
    showAllRegistries?: BoolFieldUpdateOperationsInput | boolean
    cacheRegistries?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConfigUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pdfGenerate?: BoolFieldUpdateOperationsInput | boolean
    showAllRegistries?: BoolFieldUpdateOperationsInput | boolean
    cacheRegistries?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlRegisterUpsertWithWhereUniqueWithoutUserInput = {
    where: ControlRegisterWhereUniqueInput
    update: XOR<ControlRegisterUpdateWithoutUserInput, ControlRegisterUncheckedUpdateWithoutUserInput>
    create: XOR<ControlRegisterCreateWithoutUserInput, ControlRegisterUncheckedCreateWithoutUserInput>
  }

  export type ControlRegisterUpdateWithWhereUniqueWithoutUserInput = {
    where: ControlRegisterWhereUniqueInput
    data: XOR<ControlRegisterUpdateWithoutUserInput, ControlRegisterUncheckedUpdateWithoutUserInput>
  }

  export type ControlRegisterUpdateManyWithWhereWithoutUserInput = {
    where: ControlRegisterScalarWhereInput
    data: XOR<ControlRegisterUpdateManyMutationInput, ControlRegisterUncheckedUpdateManyWithoutUserInput>
  }

  export type ControlRegisterScalarWhereInput = {
    AND?: ControlRegisterScalarWhereInput | ControlRegisterScalarWhereInput[]
    OR?: ControlRegisterScalarWhereInput[]
    NOT?: ControlRegisterScalarWhereInput | ControlRegisterScalarWhereInput[]
    id?: IntFilter<"ControlRegister"> | number
    userId?: IntFilter<"ControlRegister"> | number
    agente?: StringFilter<"ControlRegister"> | string
    fecha?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    lugar?: StringFilter<"ControlRegister"> | string
    conductor_nombre?: StringFilter<"ControlRegister"> | string
    licencia_tipo?: StringFilter<"ControlRegister"> | string
    licencia_numero?: StringFilter<"ControlRegister"> | string
    licencia_vencimiento?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    empresa_select?: StringFilter<"ControlRegister"> | string
    dominio?: StringFilter<"ControlRegister"> | string
    interno?: StringNullableFilter<"ControlRegister"> | string | null
    c_matriculacion_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    c_matriculacion_cert?: StringNullableFilter<"ControlRegister"> | string | null
    seguro_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    seguro_cert?: StringNullableFilter<"ControlRegister"> | string | null
    rto_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    rto_cert?: StringNullableFilter<"ControlRegister"> | string | null
    tacografo_venc?: DateTimeNullableFilter<"ControlRegister"> | Date | string | null
    tacografo_cert?: StringNullableFilter<"ControlRegister"> | string | null
    createdAt?: DateTimeFilter<"ControlRegister"> | Date | string
    updatedAt?: DateTimeFilter<"ControlRegister"> | Date | string
  }

  export type UserCreateWithoutConfigInput = {
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    controlRegister?: ControlRegisterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfigInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    controlRegister?: ControlRegisterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfigInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfigInput, UserUncheckedCreateWithoutConfigInput>
  }

  export type UserUpsertWithoutConfigInput = {
    update: XOR<UserUpdateWithoutConfigInput, UserUncheckedUpdateWithoutConfigInput>
    create: XOR<UserCreateWithoutConfigInput, UserUncheckedCreateWithoutConfigInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConfigInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConfigInput, UserUncheckedUpdateWithoutConfigInput>
  }

  export type UserUpdateWithoutConfigInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    controlRegister?: ControlRegisterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConfigInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    controlRegister?: ControlRegisterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutControlRegisterInput = {
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    config?: UserConfigCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutControlRegisterInput = {
    id?: number
    email: string
    name?: string | null
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    config?: UserConfigUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutControlRegisterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutControlRegisterInput, UserUncheckedCreateWithoutControlRegisterInput>
  }

  export type CertificateDocumentCreateWithoutControlInput = {
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description?: string | null
    uploadedAt?: Date | string
  }

  export type CertificateDocumentUncheckedCreateWithoutControlInput = {
    id?: number
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description?: string | null
    uploadedAt?: Date | string
  }

  export type CertificateDocumentCreateOrConnectWithoutControlInput = {
    where: CertificateDocumentWhereUniqueInput
    create: XOR<CertificateDocumentCreateWithoutControlInput, CertificateDocumentUncheckedCreateWithoutControlInput>
  }

  export type CertificateDocumentCreateManyControlInputEnvelope = {
    data: CertificateDocumentCreateManyControlInput | CertificateDocumentCreateManyControlInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutControlRegisterInput = {
    update: XOR<UserUpdateWithoutControlRegisterInput, UserUncheckedUpdateWithoutControlRegisterInput>
    create: XOR<UserCreateWithoutControlRegisterInput, UserUncheckedCreateWithoutControlRegisterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutControlRegisterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutControlRegisterInput, UserUncheckedUpdateWithoutControlRegisterInput>
  }

  export type UserUpdateWithoutControlRegisterInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: UserConfigUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutControlRegisterInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: UserConfigUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CertificateDocumentUpsertWithWhereUniqueWithoutControlInput = {
    where: CertificateDocumentWhereUniqueInput
    update: XOR<CertificateDocumentUpdateWithoutControlInput, CertificateDocumentUncheckedUpdateWithoutControlInput>
    create: XOR<CertificateDocumentCreateWithoutControlInput, CertificateDocumentUncheckedCreateWithoutControlInput>
  }

  export type CertificateDocumentUpdateWithWhereUniqueWithoutControlInput = {
    where: CertificateDocumentWhereUniqueInput
    data: XOR<CertificateDocumentUpdateWithoutControlInput, CertificateDocumentUncheckedUpdateWithoutControlInput>
  }

  export type CertificateDocumentUpdateManyWithWhereWithoutControlInput = {
    where: CertificateDocumentScalarWhereInput
    data: XOR<CertificateDocumentUpdateManyMutationInput, CertificateDocumentUncheckedUpdateManyWithoutControlInput>
  }

  export type CertificateDocumentScalarWhereInput = {
    AND?: CertificateDocumentScalarWhereInput | CertificateDocumentScalarWhereInput[]
    OR?: CertificateDocumentScalarWhereInput[]
    NOT?: CertificateDocumentScalarWhereInput | CertificateDocumentScalarWhereInput[]
    id?: IntFilter<"CertificateDocument"> | number
    controlId?: IntFilter<"CertificateDocument"> | number
    certificateType?: EnumCertificateTypeFilter<"CertificateDocument"> | $Enums.CertificateType
    certificateNumber?: StringFilter<"CertificateDocument"> | string
    publicId?: StringNullableFilter<"CertificateDocument"> | string | null
    fileName?: StringFilter<"CertificateDocument"> | string
    filePath?: StringFilter<"CertificateDocument"> | string
    fileSize?: IntFilter<"CertificateDocument"> | number
    mimeType?: StringFilter<"CertificateDocument"> | string
    description?: StringNullableFilter<"CertificateDocument"> | string | null
    uploadedAt?: DateTimeFilter<"CertificateDocument"> | Date | string
  }

  export type ControlRegisterCreateWithoutCertificatesInput = {
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutControlRegisterInput
  }

  export type ControlRegisterUncheckedCreateWithoutCertificatesInput = {
    id?: number
    userId: number
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlRegisterCreateOrConnectWithoutCertificatesInput = {
    where: ControlRegisterWhereUniqueInput
    create: XOR<ControlRegisterCreateWithoutCertificatesInput, ControlRegisterUncheckedCreateWithoutCertificatesInput>
  }

  export type ControlRegisterUpsertWithoutCertificatesInput = {
    update: XOR<ControlRegisterUpdateWithoutCertificatesInput, ControlRegisterUncheckedUpdateWithoutCertificatesInput>
    create: XOR<ControlRegisterCreateWithoutCertificatesInput, ControlRegisterUncheckedCreateWithoutCertificatesInput>
    where?: ControlRegisterWhereInput
  }

  export type ControlRegisterUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: ControlRegisterWhereInput
    data: XOR<ControlRegisterUpdateWithoutCertificatesInput, ControlRegisterUncheckedUpdateWithoutCertificatesInput>
  }

  export type ControlRegisterUpdateWithoutCertificatesInput = {
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutControlRegisterNestedInput
  }

  export type ControlRegisterUncheckedUpdateWithoutCertificatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlRegisterCreateManyUserInput = {
    id?: number
    agente: string
    fecha?: Date | string | null
    lugar: string
    conductor_nombre: string
    licencia_tipo: string
    licencia_numero: string
    licencia_vencimiento?: Date | string | null
    empresa_select: string
    dominio: string
    interno?: string | null
    c_matriculacion_venc?: Date | string | null
    c_matriculacion_cert?: string | null
    seguro_venc?: Date | string | null
    seguro_cert?: string | null
    rto_venc?: Date | string | null
    rto_cert?: string | null
    tacografo_venc?: Date | string | null
    tacografo_cert?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlRegisterUpdateWithoutUserInput = {
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateDocumentUpdateManyWithoutControlNestedInput
  }

  export type ControlRegisterUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateDocumentUncheckedUpdateManyWithoutControlNestedInput
  }

  export type ControlRegisterUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    agente?: StringFieldUpdateOperationsInput | string
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar?: StringFieldUpdateOperationsInput | string
    conductor_nombre?: StringFieldUpdateOperationsInput | string
    licencia_tipo?: StringFieldUpdateOperationsInput | string
    licencia_numero?: StringFieldUpdateOperationsInput | string
    licencia_vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa_select?: StringFieldUpdateOperationsInput | string
    dominio?: StringFieldUpdateOperationsInput | string
    interno?: NullableStringFieldUpdateOperationsInput | string | null
    c_matriculacion_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    c_matriculacion_cert?: NullableStringFieldUpdateOperationsInput | string | null
    seguro_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seguro_cert?: NullableStringFieldUpdateOperationsInput | string | null
    rto_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rto_cert?: NullableStringFieldUpdateOperationsInput | string | null
    tacografo_venc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tacografo_cert?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateDocumentCreateManyControlInput = {
    id?: number
    certificateType: $Enums.CertificateType
    certificateNumber: string
    publicId?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    description?: string | null
    uploadedAt?: Date | string
  }

  export type CertificateDocumentUpdateWithoutControlInput = {
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateDocumentUncheckedUpdateWithoutControlInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateDocumentUncheckedUpdateManyWithoutControlInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificateType?: EnumCertificateTypeFieldUpdateOperationsInput | $Enums.CertificateType
    certificateNumber?: StringFieldUpdateOperationsInput | string
    publicId?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}